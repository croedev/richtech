리치테크(Rich Tech club) 부자클럽은 국내외 가장 성장성과 안정성을 갖춘 주식을 투자하고 있는 네트워크마케팅(MLM회사)이다

[주요기능]
1.로그인, 회원가입, 로그아웃, 회원정보수정,비밀번호변경
2.상품구매,상품구매내역,
3.출금신청,출금내역,
4.보너스내역 - 추천수당. 직급수당, 센터수수료
5.조직도-후원조직도, 추천조직도
6.전자지갑 : 수수료조회, USDP충전,USDT출금신청,출금내역,
7.공지사항


[주요메뉴구성]
[홈]-대쉬보드,좌우실적,직급수당,
[상품]-상품구매,상품구매내역
[회원]-회원가입,회원정보수정,비밀번호변경,로그인,로그아웃,[후원조직도],[추천조직도]
[전자지갑]-USDP충전,USDT출금신청,출금내역 [보너스조회]-추천수당,직급수당
[인증서] 주식보관증서
[공지사항] 게시판

[관리자페이지]
1.회원관리: 회원정보,수정,검색조회
2.주문관리: 주문내역,검색조회
3.수당관리: 추천수당,직급수당,센터수수료
4.출금신청 : 신청내역확인, 출금처리
5.공지사항
6.주식관리 : 지급자,생년월일,연락처,주소,주식보관증서
7.마감정산하기 -매일 10시.. 만약 특정날짜, 기간정해서 마감을 재정산해야 할수도 있음.



[후원조직,추천조직]
-회원가입시 후원인과 추천인을 선택한다.
-후원인으로만 연결되는 조직을 후원조직이라 하고, 추천인으로만 연결되는 것은 추천조직이라 한다.
-모든 회원은 자신을 중심으로 후원조직도와 추천조직도를 갖는다.

1.후원조직 : 
바이너리 방식으로 조직을 구성한다. 즉, 내 아래 2명이상의 피후원인을 둘수없다. 
신규회원이 회원등록시 후원자를 선택할때, 그 선택된 후원자가 이미 자신이 후원하는자가 2명이 되어 있으면 더이상 후원자로 등록할수 없다.
이때 신규회원은 다른 회원, 즉, 아직 2명이 안된 후원자를 찾아 입력하든지, 아니면 랜덤을 선택하면 시스템에서 임의로 두라인이 아직 안된 회원을 찾아, 시스템이 자동으로 후원인을 지정하여 등록한다.
누구나 자신의 직라인으로 2명이상의 후원자를 둘수없고, 오직 내 아래 2명의 후원자먼만을 둘수있다.

2.추천조직 : 
본인이 추천한 사람, 그 추천된 사람이 또 추천을 하는 추천인을 연결하여 조직을 구성한다.
신규회원은 자신을 추천한 사람을 선택하여 등록할수 있다. 추천은 초대인원수 제한은 없다.


[상품의 종류]
[1].상품의 가격 및  지급되는 주식(stock)과 토큰(token)
상품코드:Rich-500  : 가격: 500$, --> 지급주식: 주식100주,  리치토큰 200개
상품코드:Rich-1000 : 가격: 1000$, --> 지급주식: 주식200주, 리치토큰 400개
상품코드:Rich-2000 : 가격: 2000$, --> 지급주식: 주식400주, 리치토큰 800개
상품코드:Rich-3000 : 가격: 3000$, --> 지급주식: 주식600주, 리치토큰 1200개
상품코드:Rich-5000 : 가격: 5000$, --> 지급주식: 주식1000주, 리치토큰 2000개
상품코드:Rich-7000 : 가격: 7000$, --> 지급주식: 주식1400주, 리치토큰 2800개
상품코드:Rich-10000 : 가격: 10000$, --> 지급주식: 주식2000주, 리치토큰 4000개
상품코드:Rich-30000 : 가격: 30000$, --> 지급주식: 주식6000주, 리치토큰 12000개
상품코드:Rich-50000 : 가격: 50000$, --> 지급주식: 주식10000주,  리치토큰 20000개

[결제방식]
1.USDP(결제포인트) 결제 : 
1)사전에 회사의 지정된 계좌에 USDT를 송금하고, 이에해당하는 결제용 USDP 포인트를 충전한다. 
2)그리고 상품구매시 결제용 USDP로 결제한다.
3)상품결제시 잔고에 충분한 USDP포인트가 있어야하고, 상품결제시 잔고에서 차감된다.



-----
[수수료 지급]
1.수수료는 추천수당과 직급수당 및 센터수당이 있다.
2.모든수당은 function_bonus.php 파일에서 수당계산 함수를 모아서 다른곳에서 함수를 호출하여 사용한다.
3.추천수당은 calculate_referral_bonus() 함수를 호출한다. 테이블은 
4.직급수당은 calculate_rank_bonus() 함수를 호출한다.
5.센터수당은 calculate_center_bonus() 함수를 호출한다.


[1].추천수당 : 20% 
1. 추천수당은 추천인의 추천라인을 타고 올라가면서 각 단계별로 지급된다.
2. 추천수당은 각 단계별로 다음과 같이 지급된다.
1대 추천시 10% 지급
2대 추천시 3% 지급
3대 추천시 3% 지급
4대 추천시 2% 지급
5대 추천시 2% 지급


[2].추천수수료 계산

실제 코딩할때는 추천수수료 로직은, 실제 매출을 발생시킨 자를 기준으로 계산한다.
만약 누군가 매출1건이 발생하면 , 그 사람의 매출을 가지고 추천라인을 타고 올라가서 상위5명에게 합계 20%를 지급한다.

좀더 정확하게 말하면, 
1) 매출자의 추천라인 위로 타고 올라가서 맨 처음 위치한 사람에게 10% 추천수수료를 지급한다.
2) 그 다음 위치한 사람에게 3% 추천수수료를 지급한다.
3) 그 다음 위치한 사람에게 3% 추천수수료를 지급한다.
4) 그 다음 위치한 사람에게 2% 추천수수료를 지급한다.
5) 그 다음 위치한 사람에게 2% 추천수수료를 지급한다.

만약 상위 5명이 존재하지 않으면, 타고 올라가다가 더이상 없으면 종료한다.


2. 직급수당 

[1].직급달성 계산

[후원조직 누적매출]
회원가입시 모든 회원은 후원인과 추천인란에, 먼저 등록한 회원중에서 후원인과 추천인을 선택한다.
후원인으로만 연결되는 조직을 후원조직이라 하고, 추천인으로만 연결되는 것은 추천조직이다.
직급달성에 필요한 실적은 후원조직의 좌,우실적중 소실적의 매출이다.

[직급달성 계산]
직급은 1스타에서 ~7스타까지 모두 7단계가 있다.
직급의 승격기준은 [자신의 매출]조건 & [직추천인 수]조건 & [소실적매출]조건이 모두 만족하였을때 승급한다.
모든 매출은 누적이다.

1).자신의 매출 : 자신이 직접 매출한 금액을 누적한 금액이다. users테이블의 myAmount 컬럼.
2).직추천인 수 : 자신이 추천한 사람이 직접 매출한 금액을 누적한 금액이다. users테이블의 referral_count 컬럼.
3).소실적매출 : 자신을 중심으로 좌측에 있는 사람과 우측에 있는 사람의 산하로 매출을 집계한 금액에서 적을쪽의 매출을 소실적매출이라 한다.
users테이블의 left_amounts, right_amounts 컬럼 중 적은쪽의 매출


3.누적실적
본인의 실적 : 첫 등록부터 계속누적이다.
좌실적(L) : 자신의 왼쪽 후원인 산하로 발생된 모든 매출의 누적 합계이다. 주요정보는 좌실적 회원수,좌실적 매출누적, 당일매출합계이다.
우실적(R) : 자신의 오른쪽 후원인 산하로 발생된 모든 매출의 누적 합계이다. 주요정보는 우실적 회원수,우실적 매출누적, 당일매출합계이다.
소실적(S) : 좌실적과 우실적중 작은 쪽의 실적을 소실적이라한다.

나의 실적에서 각각을 누적하여 기록하고 있어야 한다.

4.직급 승급 기준
1스타는 본인매출 1000$ 이상, 추천인원 2명이상 되고, 소실적의 누적실적이 10000$ 이상이면 달성한다.
2스타는 본인매출 1000$ 이상, 추천인원 3명이상 되고, 소실적의 누적실적이 30000$ 이상이면 달성한다.
3스타는 본인매출 2000$ 이상, 추천인원 4명이상 되고, 소실적의 누적실적이 50000$ 이상이면 달성한다.
4스타는 본인매출 2000$ 이상, 추천인원 5명이상 되고, 소실적의 누적실적이 100000$ 이상이면 달성한다.
5스타는 본인매출 3000$ 이상, 추천인원 6명이상 되고, 소실적의 누적실적이 300000$ 이상이면 달성한다.
6스타는 본인매출 3000$ 이상, 추천인원 7명이상 되고, 소실적의 누적실적이 700000$ 이상이면 달성한다.
7스타는 본인매출 3000$ 이상, 추천인원 8명이상 되고, 소실적의 누적실적이 1000000$ 이상이면 달성한다.

실제코딩시에는 이 조건이 변경될수도 있어서, 별도로 config.php 파일에 승급조건을 상수로 정의해둔다.
직급이 계산되면 그 승급내용이 rank_history테입르에 저장된다.

직급수당은 전일까지 직급으로 오늘의 매출에 대하여 지급하는 것이다.
매일 매출이 발생하면 주문테이블 orders에 주문내역이 저장되고, 그 매출에 대하여, 모든 수당인 추천수당, 직급수당, 센터수당 까지 다 지급한후에 내일 적용할 직급계산을 하여, users테이블의 rank의 값을 업데이트시키고, rank_history 테이블에 직급변동사항이 기록된다.


[직급수당 지급요율표]
1스타 : 9% 회사당일매출합*9%를 1스타직급자수만큼 나누어 각자에게 지급한다.
2스타 : 4% 회사당일매출합*4%를 (2스타직급자수+3스타직급자수)만큼 나누어 각자에게 지급한다.
3스타 : 3% 회사당일매출합*3%를 (3스타직급자수+4스타직급자수)만큼 나누어 각자에게 지급한다.
4스타 : 2% 회사당일매출합*2%를 (4스타직급자수+5스타직급자수)만큼 나누어 각자에게 지급한다.
5스타 : 2% 회사당일매출합*2%를 (5스타직급자수+6스타직급자수)만큼 나누어 각자에게 지급한다.
6스타 : 2% 회사당일매출합*2%를 (6스타직급자수+7스타직급자수)만큼 나누어 각자에게 지급한다.
7스타 : 2% 회사당일매출합*2%를 7스타직급자수만큼 나누어 각자에게 지급한다.
전체합계 : 20%  

직급수당 지급방식 : 
매일 회사매출로 각 회원들의 직급에 따라 매일 직급수당을 지급한다. 
지급후 bonus_rank 테이블에 직급수당 지급내역을 기록한다.
각자의 users테이블의 bonus_rank 컬럼에 직급수당을 누적 업데이트한다.
users테이블의 point컬럼값도 포인트에 합계가 누적된다. (모든수당은 발생후 포인트로 지급됨으로 포인트의 합계는 계속누적된다.)


[직급수당 계산 예시]
1. 전날까지 직급 즉, 현재 자신의 직급, 아직 오늘 실적이 반영되지 않은 어제의 직급으로 직급수당은 계산한다.
어제 정산후 확정된 직급자수를 오늘 직급수당 정산시에 사용한다.

<어제까지 확정된 직급자수>
1스타 직급자수 : a명
2스타 직급자수 : b명
3스타 직급자수 : c명
4스타 직급자수 : d명
5스타 직급자수 : e명
6스타 직급자수 : f명
7스타 직급자수 : g명

상위직급자로 갈수록 하위매출을 중복으로 직급수당을 지급받을수 있다.

1스타수당(9%) : 회사매출의 9%를 1스타직급자 숫자만큼 나누어 각자에게 지급한다. 
          즉, 각자 1스타직급자에게 total_sales * 0.09 / a 만큼 지급한다.
2스타수당(4%) : 회사매출의 4%를 (2스타 숫자와 3스타 숫자를 합친 수)만큼 나누어 2스타와 3스타 각자에게 "2스타수당"이라는 명목으로 지급한다. 
         즉, 각자 2스타와 3스타 직급자에게 total_sales * 0.04 / (b+c) 만큼 "2스타수당"이라는 명목으로 각자에게 지급한다.
3스타수당(3%) : 회사매출의 3%를 (3스타 숫자와 4스타숫자)를 합친 수만큼 나누어 3스타와 4스타 각자에게 "3스타수당"이라는 명목으로 지급한다. 
         즉, 각자 3스타와 4스타 직급자에게 total_sales * 0.03 / (c+d) 만큼 "3스타수당"이라는 명목으로 각자에게 지급한다.
4스타수당(2%) : 회사매출의 2%를 (4스타 숫자와 5스타숫자)를 합친 수만큼 나누어 4스타와 5스타 각자에게 "4스타수당"이라는 명목으로 지급한다.
          즉, 각자 4스타와 5스타 직급자에게 total_sales * 0.02 / (d+e) 만큼 "4스타수당"이라는 명목으로 각자에게 지급한다.
5스타수당(2%) : 회사매출의 2%를 (5스타 숫자와 6스타숫자)를 합친 수만큼 나누어 5스타와 6스타 각자에게 "5스타수당"이라는 명목으로 지급한다.
          즉, 각자 5스타와 6스타 직급자에게 total_sales * 0.02 / (e+f) 만큼 "5스타수당"이라는 명목으로 각자에게 지급한다.
6스타수당(2%) : 회사매출의 2%를 (6스타 숫자와 7스타숫자)를 합친 수만큼 나누어 6스타와 7스타 각자에게 "6스타수당"이라는 명목으로 지급한다.
          즉, 각자 6스타와 7스타 직급자에게 total_sales * 0.02 / (f+g) 만큼 "6스타수당"이라는 명목으로 각자에게 지급한다.
7스타수당(2%) : 회사매출의 2%를 (7스타 숫자)를 합친 수만큼 나누어 7스타 각자에게 "7스타수당"이라는 명목으로 지급한다.
          즉, 각자 7스타 직급자에게 total_sales * 0.02 / g 만큼 "7스타수당"이라는 명목으로 각자에게 지급한다. 

즉,1스타직급자는 1스타직급수당만 받고, 
2스타직급자는 2스타직급수당만 받고, 
3스타직급자는 2스타직급수당과 3스타직급수당 모두를 받을수있다.
4스타직급자는 3스타직급수당과 4스타직급수당 모두를 받을수있다.
5스타직급자는 4스타직급수당과 5스타직급수당 모두를 받을수있다.
6스타직급자는 5스타직급수당과 6스타직급수당 모두를 받을수있다.
7스타직급자는 6스타직급수당과 7스타직급수당 모두를 받을수있다.


[직급승급 계산]
1)직급수당이 모든 직급자에게 지급이 완료되면, 오늘 발생한 매출로 인해 승급할 직급자를 계산한다.
2)오늘 발생한 매출로 인한 각자의 실적 기록값을 모두 업데이트한다.
3)직급 승급에 필요한 본인실적, 좌실적, 우실적, 소실적, 직접 추천한 추천인수를 계산한다.
4)각 누적실적이 직급 승급기준을 달성하면 승급한다. 직급승급 테이블 rank_history 에 저장한다.


모든 매출은 트론기반 TRC20 테더로 결제한다. 
모든 회원은 트론지갑이 회원가입시 자동생성된다. 또는 이미 회사에서 생성한 트론지갑의 주소를 회원가입시 자동으로 매칭시킨다.
이는 개인키를 회사가 갖고 있어야 하기 때문이다.


[센터보너스]
1.자신의 소속 센터의 회원들이 매일 발생한 매출의 2%를 지급한다.
2.센터보너스는 센터장에게 user_id로 지급되고, 
3.회원가입시 organization 컬럼에 소속을 선택하면, organization테이블의 센터장의 user_id에 매일 자신의 센터소속의 매출의 2%를 지급한다.
4.매일 매출의 마감시 각 센터매출도 정산을 한다.
5.정산기준은 users테이블의 organization 컬럼에 소속된 센터를 소속으로 한 회원들의 매출을 매일 집계하여 그 매출의 2%를 센터장의 user_id에 지급된다.
6.orders테이블에 저장된 모든 당일의 주문건에 대하여, 센터수수료를 정산한후, 센터수수료는 bonus_center 테이블에 저장한다.

-----

3.[수당 지급 절차]
1.모든 시간은 GMT+9 서울시간으로 계산한다.
2.당일 회사전체매출을 집계한다. 회사전체매출은 00:00시에서 ~22:00시까지 발생한 매출을 집계한다.
(10시부터-24시까지는 전날매출로 계산한다. 이때 상품구매할수 없다.)
3.회사매출 : total_company_sales
3.수수료를 정산하는 시간은 매일 저녁 10시에 마감하고 수수료 정산하고, 12시이후부터 다음날의 새 매출을 시작한다.
4.주문(orders)테이블에 저장된 모든 당일의 주문건에 대하여, 추천수수료, 직급수수료, 센터수수료를 지급한다. 직급수수료는 어제까지 계산된 직급에 따른 오늘의 매출을 집계하여 수수료를 정산한다.
5.계산된 수수료는 추천수수료는 bonus_referral, 직급수수료는 bonus_rank, 센터수수료는 bonus_center 테이블에 저장한다. 그리고 users테이블에 지급된 각수당을 업데이트한다. 즉, users테이블의 bonus_referral, bonus_rank, bonus_center에 업데이트 된다. 또한 모든 발생수당은 포인트로 지급되므로, 각 수당발생시 point컬럼값은 합쳐서 업데이트된다.

6.지급이 완료되면, 주문(orders)테이블에 state_paid="completed" 지급완료 처리한다. 
7.수수료지급이후, 내일 직급수수료를 지급할 직급을 당일 주문건을 기반으로 모든 회원에게 당일의 각자의 좌실적,우실적,본인실적,직추천자수,소실적을 users테이블에 업데이트 한다. 
8.이렇게 한후 직급승급을 계산한다. 직급승급이 완료되면, 변동된 직급을 rank_history 테이블에 저장한다.
9. 직급을 계산하기위한, 모든회원은 본인실적(myAmount), 직추천자수(referral_count), 좌실적(left_amount), 우실적(right_amount) 을 모두 정산시 매일 업데이트 한다.
10.출금신청은 매일 09:00~05:00시에 활성화되고, 이때 신청된 출금신청은 출금요청(withdrawals)테이블에 저장된다. 여기에서 관리자는 출금신청을 확인하고 출금을 진행한다. 
11.출금완료 버튼은 관리자 페이지에서 수행하면, 출금요청(withdrawals)테이블에 state="completed" 처리한다.
12.회원은 자신의 출금요청리스트에서 상태가 지급완료로 표시된다.


[수당조회 페이지]----------------
bonus.php 페이지를 만든다.
모든 회원들은 자신의 수당과 내역을 조회할수 있다.

--------
수수료 현황

이름 : 홍길동(honggildong)
직급 : 2스타 (2024.3.13 승급)

[누적수수료]
추천수수료 : 100$
직급수수료 : 200$
센터수수료 : 300$

탭이나 버튼으로 클릭시 해당수당만 보임
[전체][추천수당][직급수당][센터수당]
[2024.11.01]~[2024.11.20][검색하기]    날짜선택버튼 추가
--------------------------
[추천수당 세부내역]
no,    날짜,    수당종류,  지급금액, 매출근거     
1  2024.11.20  추천수수료  100$     홍길순(hgs1123) 
                                   매출: 1000$ 
                                   비율 : 1대(10%)

모바일에 최적화되도록 표의 칸을 매출근거란에 모아서 표시
페이징 처리 [이전]1,2,3,4,5[다음] 버튼 추가



[직급수당 선택시 내역표시 ]
no. 날짜      본인직급 수당종류   지급금액  공유직급    공유비율 
1 2024.11.23  1스타   1스타수당  100$     1스타         9%
2 2024.11.24  2스타   2스타수당  200$     2스타,3스타    4%
3 2024.11.25  3스타   2스타수당  200$     2스타,3스타    3%
4 2024.11.25  3스타   3스타수당  100$     3스타,4스타    3%
5 2024.11.26  4스타   3스타수당  300$     3스타,4스타    2%
6 2024.11.26  4스타   4스타수당  200$     4스타,5스타    2%

페이징 처리 [이전]1,2,3,4,5[다음] 버튼 추가

--------
1스타는 자신들직급숫자끼리 공유
2스타수당은 2,3스타가 공유
...
--------

[센터수당 선택시 내역표시 ]
no. 날짜      센터매출  지급율 지급금액  지급결과 
1 2024.11.23  100000$   2%   200000   처리완료
2 2024.11.24  200000$   2%   400000   처리완료
3 2024.11.25  300000$   2%   600000   처리완료
4 2024.11.26  400000$   2%   800000   처리완료
5 2024.11.27  500000$   2%   1000000  처리완료

페이징 처리 [이전]1,2,3,4,5[다음] 버튼 추가



[회사전체 일일통계]
일일 회사전체매출 및 통계현황을 나타내는 테이블이 필요하다. company_state 테이블이다. 매일 마감정산시 기록된다.
일자, 가입회원,회사매출, 회사입금금액,주시계좌,마스터계좌,회사출금금액, 회사지급주식, 회사지급토큰수, 추천수수료, 직급수수료, 센터수수료, 1스타,2스타,3스타,4스타,5스타,6스타,7스타,센터수 등이다. (이부분 DB생성후 일마감정산후 통계를 집약해서 company_state 테이블에 저장한다.)
관리자페이지에서 이를 조회하고 관리할 페이지 admin_copmpany.php를 만든다.




------
나는 개발초보자이고, 당신은 25년차 전문가이다. 
당신이 중간에 코드를 같은 패턴이라고 일부 생략해 버리면, 초보자인 내가 자체적으로 작성하기 어렵고 실수하기 쉽다.
위의 코드들 중에 당신이 생략한 생략된 코드가 있는데 그 생략된 코드를 모두 완성하라.
1. 특히 후원조직을 추적해야한다며 생략한, 좌실적,우실적 소실적 계산해내는 로직과 함수 -> 매우중요하니 전체코드를 완벽하게 완성하라. 
이것은 바이너리 마케팅의 핵심이니 다시한번 강조한다. 

2. 회원들이 가장 많이 찾는 수당계산 부분도, 추천수당, 직급수당, 센터수당 등 모든 수당이 유저들 보는 페이지가 생략되지 않도록 모든 수당이 완벽하게 조회 검색되도록 작성하라.

3. 회사계산통계 항목도 가능한 생략하지 말고 전체코드를 완성하라.
-------
[직급자 승급조건 중 --좌우실적에서 소실적을 찾아 소실적이 특정금액 이상누적되어야 한다.]

직급수당을 계산하려면 직급자를 반드시 확정하여야 한다.
직급자 승급기준을 미리 점검하고 3가지 조건을 만족하는 유저를 찾아야 한다.

1)본인누적실적 : 로직완료,코드완성됨
2)직접추천한 회원수 : 로직완료,코드완성됨
3)좌실적,우실적,소실적 : 로직생략됨,미완성, 이부분 매우 중요함(재작업필요).

[좌실적,우실적 소실적 계산해내는 로직과 함수 ] 바이너리 마케팅 중요함.

나를 기준으로 후원조직을 추적한다.
즉, 나를 기준으로, 우선 한쪽으로 출발하여 (이를 좌실적이라 한다.)  
좌실적에서 찾고자 하는 것은 좌실적 전체회원수(left_members), 좌실적 전체실적금액(left_amounts)이다.

1.나의 id를 자신의 sponsored_id 컬럼에 후원인으로 나의 id를 후원인으로 갖고있는 회원을 찾아 좌실적 1대라고 한다.
1대 회원들 1명당 회원수는 +1을 증가시키고 (left_members)와 그 개인실적금액을 (left_amounts)값에 누적해 나간다.

2. 1대 회원들의 id를 자신의 sponsored_id 컬럼에 1대의 id를 갖고있는  회원을 찾아 2대 회원이라고 한다.
2대 회원들 1명당 회원마다 회원수(left_members)는 +1을 증가시키고, 그 개인실적금액을 (left_amounts)값에 누적해 나간다.

3. 2대 회원들의 id를 자신의 sponsored_id 컬럼에 2대의 id를 갖고있는  회원을 찾아 3대 회원이라고 한다.
3대 회원들 1명당 회원마다 회원수(left_members)는 +1을 증가시키고, 그 개인실적금액을 (left_amounts)값에 누적해 나간다.

더이상 좌실적을 추적할 수 없을때까지 이런식으로 좌실적을 추적하여 좌실적 전체회원수(left_members), 좌실적 전체실적금액(left_amounts)을 계산한다.

[우실적 ]
좌실적이 완료되면, 같은 원리로 나를 기준으로 다른한쪽 여기서는 우실적이라 한다.
즉, 나를 기준으로, 다른 한쪽으로 출발하여 (이를 우실적이라 한다.)  
우실적에서 찾고자 하는 것은 우실적 전체회원수(right_members), 우실적 전체실적금액(right_amounts)이다.

1. 나의 남은 한쪽 회원을 찾아 그 회원의 sponsored_by 컬럼에, 나의 id를 후원인으로 갖고있는 회원을 찾아 우실적 1대라고 한다.
우실적 1대회원 1명당 회원수는 +1을 증가시키고 (right_members)와 그 개인 실적금액을 (right_amounts)값에 누적해 나간다.
2. 1대 회원들의 id를 자신의 sponsored_by 컬럼에 1대의 id를 갖고있는  회원을 찾아 2대 우실적 회원이라고 한다.
2대 회원들 1명당 회원마다 회원수(right_members)는 +1을 증가시키고, 그 개인실적금액을 (right_amounts)값에 누적해 나간다.
3. 2대 회원들의 id를 자신의 sponsored_by 컬럼에 2대의 id를 갖고있는  회원을 찾아 3대 우실적 회원이라고 한다.
3대 회원들 1명당 회원마다 회원수(right_members)는 +1을 증가시키고, 그 개인실적금액을 (right_amounts)값에 누적해 나간다.

더이상 우실적을 추적할 수 없을때까지 이런식으로 우실적을 추적하여 우실적 전체회원수(right_members), 우실적 전체실적금액(right_amounts)을 계산한다.
이렇게 계산된 좌실적과 우실적을 비교하여 소실적을 계산한다.
소실적을 계산하는 이유는 직급자 승급조건중 좌실적과 우실적을 계산한 후 소실적의 누적금액이 기준이다.

이러한 과정을 users테이블의 모든 회원에게 반복하여 각자의 좌실적, 우실적의 회원수, 매출금액, 우실적 회원수, 매출금액 등을 누적하여 업데이트한다.


모든 회원들은 좌실적과 우실적은 갖고 있으며, 추적이 완료되면 users테이블의 left_amounts, right_amounts 컬럼에 각각 좌실적, 우실적 금액이 업데이트 된다. 또한 정보제공을 위해 모든 회원들의 left_members, right_members 디비값도 업데이트 한다.

이렇게 되면 직급계산을 위한 모든 기준을 계산하였고, users테이블에 해당 컬럼들을 업데이트 하였다.
따라서 이데이터에 따라 신규 승급자를 정하고, 그 결과를 rank_history테이블에 저장한다.

1)본인누적실적조건
2) 본인 직접추천한 회원수 조건
3) 본인의 소실적 달성조건 -- 여기로직을 위에 길게 설명함.


[다른 로직]
매일 매일 모든 회원들을 처음부터 추적하는 방법이 있지만, 그러면 너무 오래걸리고 자원낭비이다.
따라서 나를 기준으로 하위에 어제까지 누적된 좌실적 우실적의 데이터에 ++
오늘 신규로 추가된 신규회원들이나 오늘 발생한 매출만을 신규로 추적하여 어제까지 누적된 컬럼값을 매일 신규로 업데이트 해나간다.
이게 로직으로 맞는지.. 함께 검토해라.


[생략된 코드 완성하기]
저 위에서  "수당계산" 로직에서 중요한 요소를 코드가 길다는 이유로 아래와 같이 중요코를 생략하였다.
이는 직급승급에 핵심조건이다 지급수당울 주려면 생략된것이 없는 완벽한 코드를 완성하세요.


직급자 승급조건중 좌실적과 우실적을 계산한 후, 직급승급조건 중 소실적이 승급을 위한 누적금액 기준이다.

[당신이 생략한 부분의 코드 일부]
        // 좌우 실적 업데이트 (후원 조직 트리 탐색 필요)
        // 좌우 실적은 트리 구조를 탐색하여 누적해야 함
        // 여기서는 간단하게 예시로 처리

        $left_amounts = 0;
        $right_amounts = 0;

        // 좌우 실적 계산 로직 구현 필요 (트리 구조 탐색)

        // 소실적 계산
        $lesser_leg_amount = min($left_amounts, $right_amounts);


즉, 모든 수당관련 지급에 대한 전체 프로세스를 다시한번 점검해 보고, 모든 함수와 각각의 파일을 체크하여 완성, 미완성 등의 완성도를 체크하여 최종 전체버전을 제시하라.



 

전체 프로세스 요약
회원 가입 및 조직 구성

회원이 가입할 때 후원인(sponsored_by), 추천인(referred_by), 좌우 위치(position)를 설정합니다.
position 값은 left 또는 right이며, 후원 조직에서의 위치를 나타냅니다.
주문 및 매출 발생

회원이 상품을 구매하면 orders 테이블에 주문 내역이 저장됩니다.
주문 상태(status)는 completed로 설정됩니다.
정산 스크립트 실행 (settlement.php)

매일 밤 10시에 정산 스크립트가 실행됩니다.
정산 스크립트에서는 다음과 같은 작업을 수행합니다.
추천수당 계산: calculate_referral_bonus 함수 호출
직급수당 계산: calculate_rank_bonus 함수 호출
센터수당 계산: calculate_center_bonus 함수 호출
회원 실적 및 직급 업데이트: update_user_performance_and_rank 함수 호출
회사 통계 저장: save_company_state 함수 호출
수당 지급 및 회원 정보 업데이트

각 수당 계산 시 수당 내역 테이블에 기록하고, 회원의 수당 합계 및 포인트를 업데이트합니다.
회원의 좌우 실적 및 회원 수가 업데이트됩니다.
직급 승급 조건을 만족하는 회원은 직급이 상승하고, rank_history 테이블에 기록됩니다.
회원 수당 조회

회원은 bonus.php 페이지에서 자신의 수당 내역을 조회할 수 있습니다.
추천수당, 직급수당, 센터수당을 날짜별로 조회할 수 있습니다.
관리자 페이지에서 회사 통계 조회

관리자 페이지에서 admin_company.php를 통해 회사의 일일 통계를 조회할 수 있습니다.
회사의 매출, 수당 지급 합계, 직급자 수 등을 확인할 수 있습니다.







--------------------------------

[리치테크클럽 페이지구성 원칙]
- 모바일에 최적화, 다크버전, 황금색과 검은색배경,약간 진한회색 등 고급스러운 황금색 다크버전
- 부자클럽에 어울리는 고품질 디자인, 모든 페이지 디자인 일관성유지, 완성도를 매우 높게 하는것을 원칙으로 함
- 리치테크 부자들의 클럽 이미지에 맞게 디자인, 깨끗하고 깔끔한 고품질 디자인
- html,css,js,php,mysql, cdn라이브러리 활용,기능구현, bootstrap, font-awesome등 활용
- yammi.link/css/croe.2.5.0.css 포함,
- 모든 페이지에 결과나 응답이 필요할 경우, [출금요청] [확인] 버튼 및 이벤트 요청 클릭시 모달창에 표시  /모달창 함수를 만들것   모달창 제목, 모달창 내용, 모달창 버튼(확인,취소)

[페이지구성]
홈화면 : 데쉬보드,
하단바 : 홈, 상품, 농장, 마케팅, 고객센터
상단바 : < 뒤로가기, 페이지 제목

========================================

login.php
1.로그인 : 아이디, 비밀번호,  회원가입,  아이디찾기, 비밀번호찾기
  - 로그인은 아이디 또는 전화번호 또는 네이버로 로그인 가능
 - 로그인 관련 표준 디자인 및 기능사용

register.php
2.회원가입 : 아이디, 비밀번호, 이름, 국가, 휴대폰번호, 이메일, 후원아이디,추천인아이디,
  (추천링크 자동생성, 추천링크QR코드, (QR코드는 바로 회원등록페이지로 열리고, 추천인란에 자신의 아이디가 자동입력됨)


profile.php
3.개인정보 수정 페이지 :
- 아이디(변경불가), 이름, 휴대폰번호, 이메일, 후원인아이디,추천인아이디(변경불가) 나의 추천링크(수정불가), 나의 추천QR코드(수정불가), 비밀번호 변경, 주소,
[수정하기] 
--
버튼 클릭시 모달창 "수정이 완료되었습니다."
[확인]




======  상품구매 ================================


[상품구매]
상품구매에 관련 전반적 프로세스는 다음과 같다.
상품리스트(order.php)->상품결제(order_apply.php)->상품결제처리(order_process.php)->상품결제결과(order_complete.php)

1. 상품리스트 : order.php (로그인 하지 않아도 상품목록을 볼수 있음.)
order.php 에서 상품명, 상품가격, 주식지급, 토큰지급 표시 결제하기 누르면, 해당 order_id를 파라미터로 전달하여 결제페이지(order_apply.php) 결제페이지로 이동한다.

2. 상품결제 : order_apply.php (로그인 필요)  
로그인후 다시 이 페이지로 돌아온다.
여기 페이지에서.. 결제할 금액과 보유한 포인트를 표시하고, 결제하기 버튼 클릭시, 결제처리 페이지(order_process.php)에서 포인트를 차감하고 주식과 토큰을 지급하고,추천보너스를 지급하는 내부프로세스 order_process.php에서 처리한다.

[현재 포인트내역 표시]
결제페이지 이동시, 결제에 해당되는 아이템의  상품코드, 상품가격, 지급주식, 지급토큰 파라미터로 전달하여 결제페이지(order_apply.php)에서 표시하도록 한다. 

order_apply.php 결제하기 페이지 구성
해당 상품이미지만 표시하고 상품명, 가격, 지급주식, 지급토큰 표시
상품명 : Rich-500
결제금액 : 500$
결제포인트 : 500$ (현재 보유포인트 : 1000$)

--------------------------------
보유한 결제 포인트(point) 표시
--------------------------------
3. 상품결제처리 : order_process.php 
order_apply.php 에서 <결제하기>버튼 클릭시, 내부적으로 상품결제 처리(order_process.php)를 한다.
각 상품정보와 수량,결제금액을 파라미터로 전달하여 처리한다.

order_process.php 에서 처리하는 내용
1)orders테이블에 주문정보 생성, 
2)users테이블에서 포인트 차감, 
3)users테이블의 stock컬럼에 주식수량 업데이트, 주식지급내역 stock_histoy 생성
4)users테이블의 token컬럼에 토큰수량 업데이트, 토큰지급내역 token_history 생성
5)해당 주문건으로 추천보너스 지급 : 
 - 추천보너스 계산함수 호출  calculate_referral_bonus() : 별도의functions_bonus.php 수당계산 함수를 만들어서 호출한다.
 - bonus_referral 테이블에 추천보너스 내역 생성
 - users테이블의 referral_bonus 컬럼에 추천보너스 업데이트 추가

각 단계를 모듈화해서 처리하여, 주문정보 생성, 포인트 차감, 주식수량 업데이트, 토큰수량 업데이트, 추천보너스 지급 등을 순차적으로 개별 처리한다.
(필요시 주석처리하여 개별기능을 임시중단 등 할수 있도록 한다.)
추천보너스는 별도처리.

--------------------------------
order_apply.php에서 주문신청--> order_process.php에서 처리--> order_complete.php에서 결과표시.  
order_list.php에서 구매실적내역 조회확인.. 이 과정이 주문프로세스이다. 

이제 order_process.php가 처리되고, 처리후 자동으로 order_complete.php로 이동하여 결과표시하는 페이지를 구성해야 한다.

4. 상품결제 결과페이지 : order_complete.php

 결제가 완료되었습니다.
 -상품명: Rich-500
 -결제금액: 500$
 -결제포인트: 500$
 -주식지급: 100주
 -토큰지급: 200개
 -결제일 : 2024-05-01 12:00:00

[ 확인 ] 버튼 클릭시, 주문내역 페이지로 이동한다
--------------------------------
 -DB에서 orders테이블에서 완료된 결제정보를 읽어와서 표시한다.
 -상품결제에 관련된 정보들을 표시한다.



5. 구매내역 페이지 : order_list.php
*나의 구매현황
구매수량 : 총 3건, 
구매총액 : 7,000,000원
나의 직급 : 3스타

*구매 리스트 (카드형구성)
[주문 카드 목록]
기간: [2024-05-01] ~ [2024-05-03] [검색]
각 주문건을 카드 형태로 표시

주문목록1 {
  주문번호: 240001
  주문일시: 2024-05-01
  상품명: rich500
  상품가격: 500$
  주문자: 홍길동(hong)
  결제방식: USDP(point)
  주식지급: 100주
  토큰지급: 200개
  처리결과: 주식보관증발급
}

주문목록2 {
  주문번호: 240002  
  주문일시: 2024-05-02
  상품명: rich1000
  상품가격: 1000$
  주문자: 홍길동(hong)
  결제방식: USDP(point)
  주식지급: 200주
  토큰지급: 400개
  처리결과: 주식보관증발급
}

주문목록3 {
  주문번호: 240003
  주문일시: 2024-05-03
  상품명: rich2000
  상품가격: 2000$
  주문자: 홍길동(hong)
  결제방식: USDP(point)
  주식지급: 400주
  토큰지급: 800개
  처리결과: 주식보관증발급
}

[페이징] <이전 1 2 3 4 5  다음>




========================================

[관리자페이지-주문정보 처리 : admin_orders.php]
*구매 리스트
기간 : 2024-05-01 ~ 2024-05-03 [검색]
검색어 [주문번호,주문자명,상품명,상품코드] [검색]

번호 주문번호, 주문일시, 주문자명(ID),       상품명,  가격,    테더주소        입금수량  환산금액      처리결과
1. 240001 2024-05-01    홍길동(hong)     rich500    500$    1231adfadsfea  0.014     500$        처리중
2. 240002 2024-05-02    홍길동(hong)     rich1000 1000$     1231adfadsfea  0.028     1000$       처리중
3. 240003 2024-05-03    홍길동(hong)     rich2000 2000$     1231adfadsfea  0.056     2000$       처리중
...
[페이징] <이전 1 2 3 4 5 6 7 8 9 10 다음>



========================================
[출금신청 페이지]

나의 수수료 총합 : 1,208,000$
출금한 가능한 금액 : 1,208,000$ 

출금요청금액 : 100,000$
-----
출금할 트론주소 : 1231adfadsfea
테더환산수량 : 5.1 테더
수수료(5%) : 60,400$
실제출금금액 : 1,147,600$

[출금신청하기] 버튼 클릭시 모달창 표시


[출금신청] 
-----
버튼 클릭시 출금신청 <모달창>이 열림

----

<모달창> 
제목: 출금신청
--
출금요청금액 : 100,000$
수수료(5%) : 5,000$ (자동계산)
실제 출금금액 : 95,000$ (자동계산)
--
입금주소 : 1231adfadsfea

[출금신청하가] [닫기]

--------------------------------
[출금신청] 버튼 클릭시 모달창닫히고 팝업창표시
출금신청이 완료되었습니다. 
트론 네트워크에 따라 지연될수 있습니다.
리치테크 고객관리팀
info@richtech.club

--------




[관리자페이지 - 출금신청 페이지 : admin_withdraw.php]

출금신청 리스트
번호  출금신청일    출금신청자  출금신청금액  세금(3.3%)  출금수수료  실제출금금액  은행       계좌번호        예금주    처리일자   처리결과  
1.   2024-05-01  홍길동    608,000원  18,000원    12,000원  580,000원  우리은행 123-4567890-123  홍길동   pending  [출금버튼]
2.   2024-05-02  홍길동    608,000원  18,000원    12,000원  580,000원  우리은행 123-4567890-123  홍길동   pending  처리완료

----
<출금버튼> 누르면 모달창 표시
관리자가 아래 은행으로 입금완료하였나요?
우리은행 123-4567890-123 홍길동
출금금액 : 580,000원

[출금완료] [취소]
--------------------------------




[로그인 다크모드 수정]
로그인 login.php를 다크모드로 변경하라. 
디자인 검정색 황금색 기존 디자인의 일관성을 유지하고 고급스럽고 퀄리티 높게 하라.
기존에 전화번호,이메일로 로그인 했던거는 user_id로 로그인하고 비번 체크하는걸로만 하라.
users테이블에서 회원id인 user_id외 password 만으로 로그인 하라.


==================================================
wallet.php
4.전자지갑페이지
1)트론지갑등록, 트론지갑주소복사, 트론지갑주소QR코드복사
2)출금신청 : 트론지갑주소로 트론코인 출금신청하기
3)보너스지급 세부내역


dashboard.php

홍길동(id:Hongkildong)
직급 : 1스타

개인실적




API 키: TronGrid에서 API 키를 발급받았다.

[충전하기 절차]
1)회원은 <충전하기 페이지>deposits.php에서 자신이 리치클럽에서 결제할 포인트(point)를 충전할수 있다.
2)회원은 <충전하기> 페이지에서 회사주소로 USDT를 송금하면, 회사주소로 들어온 그 회원의 송금출처 주소정보와 USDT금액,트랜젝션 등 관련정보를 실시간 확인하여, deposit_usdt()함수를 호출하여 회사주소로 들어온 해당유저의 입금정보를 deposits테이블에 저장한다.
3)리치클럽 "Deposits"테이블에 그 회원의 입금 관련정보를 저장하고, 그에 해당하는 포인트(usdp)를 충전해준다. usdp포인트는 클럽내 결제에 사용된다.
4) 충전이란 deposits테이블에 회원의 송금출처 주소정보와 USDT금액,트랜젝션 등을 저장하고, users테이블에 회원의 point 잔액을 업데이트 한다.
4) 회원은 자신의 <충전페이지>에서 하단에 "충전내역 리스트"에서, 자신이 입금한 usdt 정보와 충전된 usdp(포인트)를 확인할수 있다.
(no, 충전일, 송금금액(usdt), from_user_tron_address, to_user_tron_address, 트랜젝션, 충전금액(usdp), 처리일자, 처리결과)
처리결과는 "입금확인중, 입금확인 실패, 충전완료" 중 하나이다.

5) 회사의 주소로 들어온 USDT는 두개의 트론지갑주소로 배분된다. 
주식대금 주소로 42%, 마스터주소로 58% 배분된다. 
이 마스터주소에서 모든 회원들의 수당지급, 입출금 등이 이루어진다.

<관리자페이지>  admin_deposits.php 페이지에서 모든 유저의 충전내역을 확인하고, 필요할 경우 충전처리를 선택적으로 처리할수 있다.
즉, 모든 디파짓 충전신청을 기록하되 처리결과가 충전완료 되지 않은경우, 관리자가 처리결과를 충전완료로 변경할수 있다.
또한, 관리자는 수동으로 usdt입금과는 무관하게, 특정유저에게 usdp포인트를 충전금액을 입금해줄수 있다.





[출금하기 절차]
1) 회원은 <출금신청페이지>withdrawals.php에서 자신이 보유한 USDP(point)를 USDT로 출금요청할수 있다.
2)즉, 출금신청페이지에서 회원이 "출금요청금액"과 입금받을 "트론주소"를 입력하여 신청한다.
3)일단 회원이 출금신청을 하면 withdrawals테이블에 회원의 출금신청내역이 생성된다. 
4)관리자는 출금신청내역을 확인하여 출금처리를 수동으로 개별적으로 처리한다. 출금신청은 매일 한국시간 9시부터 5시까지 신청된 내역만 처리한다. 이후 신청은 익일 처리한다. 관리자페이지에서 신청자를 선택하여 일괄 처리할수 있다. 
5)리치클럽 마스터계정에서 회원이 신청한 금액과 신청한 트론주소로 해당하는 USDT를 회원이 지정한 트론주소로 송금한다.
이때 "withdrawals"테이블에 출금처리 내역이 생성된다. 처리결과와 출금수수료3%공제도 함께 기록된다.
또한 users테이블에 회원의 point 잔액을 업데이트 한다.
6)회원들은 자신의 출금신청 페이지 하단의 출금신청내역 리스트에서, 자신이 출금신청한 USDT정보를 확인할수 있다.
*(user_id, 출금신청일, 출금신청자, 출금신청금액, 출금수수료, 실제출금금액, 송금트론주소, 트랜젝션,  처리일자, 처리결과)
처리결과는 "출금처리중, 출금처리완료, 출금처리실패" 중 하나이다.


<관리자 페이지>에서는 admin_withdraw.php 페이지에서 출금신청내역을 확인하고 출금처리를 할수 있다.
*(user_id, 출금신청일, 출금신청자, 출금신청금액, 출금수수료, 실제출금금액, 송금해줄트론주소, 트랜젝션,  처리일자, 처리결과, 출금처리하기 버튼)
*출금처리하기 버튼을 클릭하면 모달창이 뜨고, 거기에서 출금주소,출금금액,수수료,실출금액 등 정보가 한번더 표시되고, 출금하시겠습니까? 버튼 클릭시 출금처리 함수 withdraw_points() 를 호출하여 출금처리한다.



[충전하기 페이지구성] 
deposits.php 페이지에서 <충전하기>버튼 클릭시, 
리치회사 트론주소에 회원이 송금하고, 자동으로 확인한후 해당 포인트를 충전한다.
--------------------------------
1.충전하기 페이지구성 

[리치클럽재단 USDT트론주소]를 제일먼저 배치한다.

[충전하기]
[QR코드] 크게 가운데 표시 
리치클럽 트론주소 : TMh8hp5sV27apvQSAALPfCVYjZpdzB1vZf
 - 리치클럽회사 트론주소 표시[QR코드] 크게 가운데 표시 
 -QR코드 하단 : 트론주소표시 [복사하기] 버튼 클릭시 트론주소를 복사한다.

송금자 주소 : [입력]
송금한 USDT 금액 : [입력]


리치클럽 회사 트론주소로 충전금액을 입금하신후, 송금한 당신의 트론주소를 정확히 알려주세요.
리치클럽재단에 USDT(TRC20)를 송금하셨나요?
 [예] [아니오] 
--------------

버튼 클릭시 [예] 버튼 클릭시 [충전처리 함수] -> deposits테이블에 충전신청내역이 생성되고, 충전처리 함수가 호출된다.
[아니오]버튼클릭시 충전처리 취소



1. deposits 테이블에 충전신청내역 생성

CREATE TABLE `deposits` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `amount_usdt` decimal(15,6) NOT NULL COMMENT '송금한 USDT 금액',
  `amount_usdp` decimal(15,4) NOT NULL COMMENT '충전된 USDP 금액',
  `from_tron_address` varchar(100) NOT NULL COMMENT '송금한 트론 주소',
  `to_tron_address` varchar(100) NOT NULL COMMENT '회사 트론 주소',
  `transaction_id` varchar(100) NOT NULL COMMENT '트랜잭션 ID',
  `status` enum('pending','completed','failed') DEFAULT 'pending' COMMENT '처리 상태',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp(),
  `processed_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `user_id` (`user_id`),
  CONSTRAINT `deposits_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci


2. 트론네트워크 조회해서 from_tron_address 주소의 트랜젝션이 확인되면, 다시 deposits테이블에 
트랜젝션을 저장하고 실제송금된 금액(amount_usdt)으로 업데이트 하고, 동일한 usdp(포인트)를 충전한다. 
status를 충전완료로 변경한다.

이와 동시에 users테이블에 회원의 point 잔액을 업데이트 한다.

<?php
// functions_tron.php

function getTronTransaction($transaction_id) {
    $url = "https://apilist.tronscan.org/api/transaction-info?hash={$transaction_id}";

    $response = file_get_contents($url);
    if ($response === FALSE) {
        return null;
    }

    $data = json_decode($response, true);
    return $data;
}

// 회사의 트론 주소로 입금된 트랜잭션 목록을 가져오는 함수
function getIncomingTransactions($address) {
    $url = "https://api.trongrid.io/v1/accounts/{$address}/transactions/trc20?limit=200&only_confirmed=true";

    $response = file_get_contents($url);
    if ($response === FALSE) {
        return [];
    }

    $data = json_decode($response, true);
    return $data['data'] ?? [];
}




2. 충전하기 기능 구현
1). 송금한 USDT(테더) 금액 입력 : [최소 10usdt 이상] 입력가능
2). 송금한 당신의 트론주소를 정확히알려주세요 [   ]
3). 송금한 트랜젝션이 있나요?   [예] [아니오] 버튼 클릭시 충전처리 함수 charge_points() 를 호출하여 충전처리한다.

[충전안내]
*상기 재단주소로 송금한 USDT(테더)는 
*당신의 입금주소와 금액이, 블록체인에서 확인되는 즉시, 자동으로 USDP(결제포인트)로 충전 됩니다. 
*만약 블록체인 네트워크사정으로 충전이 지연될수 있으나, 영원히 기록으로 보존되니 걱정마세요.


내부전산처리
리치클럽 트론주소 : TMh8hp5sV27apvQSAALPfCVYjZpdzB1vZf
마스터주소(수당지급출금주소) : TECXxuTdgMNETyYndRkKYnM6KpH2DtwBty
주식지급주소: TUCjrVPPgrCMYty8BdFN9hCUHxxhVEjDPQ

private_key
5d77cec50cff5c9d0f99e71bc084cadc5a08e82e08adf669347378370547c0b8



https://tronscan.org/


회원이 회사 트론주소로 usdt를 송금하였다면, 
회사 트론주소에 의 충전내역은 충전페이지 하단에서 확인할수 있습니다.

-----충전 점검-----


이 deposits.php는  회원이 입력한 충전신청 정보를 deposits테이블에 일단 저장하고,, 
1.입금신청시 deposits테이블에 저장할항목, user_id,from_tron_address(보내는사람의 트론주소),to_tron_address(받는 회사트론주소),amount_usdt(보낸금액_우선저장,나중트랜젝션확인후 실제금액으로 대체),status(우선'pending'저장),created_at(신청일)
2.이 항목이 우선 디비에 저장된다. 이 저장결과가 하단 입금신청내역에 나타난다.
 이때 상태는 pending상태이고, 
 3. 이후 회사지갑을 조회하여, 해당회원의 트론주소로 회사지갑 트랜젝션이 발생했는지 체크한다.
 4.그 결과 to_tron_address에 from_tron_addressd의 해당 트랜젝션이 발생했으면, 해당 트랜젝션과 금액, 타임스탬프를 읽어와 deposits테이블의 transaction_id, amount_usdt, processed_at(트랜젝션에 기록된 타임스탬프) 컬럼에 기록한다. 그리고 status 값을 "completed"로 기록한다.
 
 5.deposits테이블에 관련정보를 저장하고, 상태값을 completed로 바꾼다. users테이블의 point값을 누적업데이트한다.
 여기까지 과정이 진행되면 디파짓과정은 완료된다.


 6. 이과정이 올바로 진행되는지 체크하라. 
 7. 우선 충전(입금)신청은 단순히 디비에 저장하는 일이므로 이것은 오류가 없이 진행되어야 하며, 충전내역 하단에 표시되어야 한다.
 -이과정은 올바로 코딩 되었는가? 당신이 체크하여 답변하고 부족하면 코드를 수정하라
 -우선 신청을 클릭하며,, 해당페이지에서 디비저장에 대한 액션이 이루어지고,, 그 결과값을 받아서,, 하단 신청내역에 입금처리중 대기중의 상태값을 띄워 주고,,

 8.디비에 입금신청이 "pending" 상태로 기록되었다면, 다음은  트론 트랜젝션 서치하는 함수호출을 한다. 아직 확인이 안된다면 "트론네트워크에 입금확인중입니다"라는 메세지를 남기고, 상태값은 pending값을 유지하면서, 에러메세지를 출력하는것이지 멈추지 않는다.

 9. 고객이 확인하기 위해 충전페이지를 방문할때마다 내역중 최종상태가 completed가 아닌 항목은,  트론함수를 호출하여 해당 트랜젝션을 조회하고,, 트랜젝션이 있을경우,,  deposits테이블에 
 그 결과 to_tron_address에 from_tron_addressd의 해당 트랜젝션이 발생했으면, 해당 트랜젝션과 금액, 타임스탬프를 읽어와 deposits테이의 transaction_id, amount_usdt, processed_at(트랜젝션에 기록된 타임스탬프) 컬럼에 기록한다. 그리고 status 값을 "completed"로 기록한다.
users테이블의 point값을 업데이트 한다.

이것을 반복하는 것이다.

이 각 단계가 올바로 코딩 되었는가? 당신이 체크하여 답변하고 부족하면 코드를 수정하라
--
amount_usdt는 일단 신청자의 입금요청금액을 기록하는것이고,, amount_usdt는 입금이 확인되었을때, 충전되는 포인트를 기록하는것이다. 따라서 입금신청시에는 pending상태에서는 usdt=신청금액이고,  usdp=0이다, 나중에 트론주소로 입금트랜젝션이 확인되면, usdt=확인된 트론 테더금액이고,  dsdp="확인된 테더금액"이고, 이때 status="completed"가 되는것이다.  이런 로직으로 구성되었는지 확인하고 수정하라.

상태값은 enum 타입으로 pending, completed, failed 3가지 상태값만 있어야 한다.
-



---------------------------------------------

[트론 참조할 샘플코드]

2. 트론 API를 통한 충전 기능 구현
트론 API를 활용하여 회사의 지갑 주소에 특정 사용자가 송금한 USDT를 모니터링합니다.

회사 지갑에 들어온 입금 내역 조회: Tron API를 통해 회사 지갑 주소로 들어온 모든 입금을 확인하고, 각 트랜잭션의 전송자, 금액, 트랜잭션 ID 등을 추출합니다.
입금이 확인되면 데이터베이스에 기록: 입금 내역이 데이터베이스의 deposits 테이블에 기록되고, 포인트 충전이 완료됩니다.
입금 내역 확인 함수
트론 API에서 특정 주소로 전송된 USDT를 확인하기 위해 TronGrid의 getEventResult를 사용할 수 있습니다.

php
코드 복사
<?php
// 충전 처리 함수
function check_deposit($tron_address) {
    $api_key = "Your_TronGrid_API_Key";
    $company_wallet_address = "Your_Company_TRON_Address";
    $tron_api_url = "https://api.trongrid.io/v1/accounts/$company_wallet_address";

    // 트론 API에서 회사 지갑으로 들어온 트랜잭션 조회
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $tron_api_url);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    curl_setopt($ch, CURLOPT_HTTPHEADER, ["TRON-PRO-API-KEY: $api_key"]);
    $response = curl_exec($ch);
    curl_close($ch);

    $data = json_decode($response, true);

    // 모든 트랜잭션을 반복하여 확인
    foreach ($data['data'] as $transaction) {
        if ($transaction['to'] == $company_wallet_address && $transaction['from'] == $tron_address) {
            $amount = $transaction['value'] / 1e6; // 금액
            $transaction_id = $transaction['txID'];
            $timestamp = $transaction['block_timestamp'];
            
            // 데이터베이스에 기록
            save_deposit_to_db($tron_address, $amount, $transaction_id, $timestamp);
        }
    }
}

// 입금 정보를 데이터베이스에 기록하는 함수
function save_deposit_to_db($tron_address, $amount, $transaction_id, $timestamp) {
    $conn = new mysqli("localhost", "username", "password", "database");

    $stmt = $conn->prepare("INSERT INTO deposits (tron_address, amount, transaction_id, timestamp) VALUES (?, ?, ?, ?)");
    $stmt->bind_param("sdsi", $tron_address, $amount, $transaction_id, $timestamp);
    $stmt->execute();
    $stmt->close();
    $conn->close();
}
3. 충전하기 페이지 UI 구성
사용자가 충전할 수 있는 페이지를 구성하여, 회사 지갑 주소를 표시하고 사용자가 송금할 수 있도록 안내합니다.

charge.php
html
코드 복사
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>충전하기</title>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script> <!-- QR코드 생성 -->
</head>
<body class="container mt-5">
    <h2>충전하기</h2>
    <div class="text-center">
        <h4>리치클럽재단 USDT 트론 주소</h4>
        <canvas id="qrcode"></canvas>
        <p id="tronAddress">Your_Company_TRON_Address</p>
        <button class="btn btn-info" onclick="copyAddress()">주소 복사</button>
    </div>

    <form id="chargeForm" class="mt-4">
        <div class="form-group">
            <label for="amount">송금한 USDT 금액</label>
            <input type="number" class="form-control" id="amount" name="amount" placeholder="최소 10 USDT" min="10" required>
        </div>
        <div class="form-group">
            <label for="tronAddressInput">송금한 트론 주소</label>
            <input type="text" class="form-control" id="tronAddressInput" name="tronAddressInput" required>
        </div>
        <div class="text-center">
            <button type="button" class="btn btn-primary" onclick="charge_points()">충전하기</button>
        </div>
    </form>

    <script>
        // QR 코드 생성
        const qr = new QRious({
            element: document.getElementById('qrcode'),
            value: "Your_Company_TRON_Address",
            size: 200
        });

        // 주소 복사 기능
        function copyAddress() {
            navigator.clipboard.writeText("Your_Company_TRON_Address").then(() => {
                alert("주소가 복사되었습니다.");
            });
        }

        // 충전 요청 처리
        function charge_points() {
            const tronAddress = document.getElementById('tronAddressInput').value;
            const amount = document.getElementById('amount').value;

            if (!tronAddress || !amount || amount < 10) {
                alert("모든 정보를 올바르게 입력하세요.");
                return;
            }

            // 서버에 충전 요청 보내기
            fetch('charge_process.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tronAddress, amount })
            }).then(response => response.json())
              .then(data => {
                if (data.success) {
                    alert("충전 요청이 접수되었습니다.");
                } else {
                    alert("충전 요청에 실패했습니다.");
                }
            }).catch(error => console.error("충전 요청 오류:", error));
        }
    </script>
</body>
</html>
4. 서버측 충전 처리 로직
charge_process.php
php
코드 복사
<?php
// JSON 데이터 받기
$request_body = file_get_contents('php://input');
$data = json_decode($request_body, true);

$tron_address = $data['tronAddress'];
$amount = $data['amount'];

// 입금 확인 및 포인트 충전 처리
check_deposit($tron_address);

echo json_encode(["success" => true]);
?>
이 구조로 설정하면, 사용자가 회사 지갑 주소로 송금한 USDT가 확인될 때마다 데이터베이스에 기록하고, 포인트를 충전할 수 있습니다.












1). 현재 보유한 포인트(point) 표시 : USDP(point)
2). 충전할 USDT() : 현재 나의 트론주소에 있는 테더(USDT) 수량 표시 : USDT(테더)

[충전하기] 버튼 클릭시, 충전하기 페이지로 이동한다.

-나의 트론주소로 USDT(테더)를 보내면, 자동으로 USDP(point)로 자동충전된다.
-즉, 나의 트론주소에 있는 테더(USDT) 수량만큼 자동으로 USDP(point)로 충전되는 프로세스 구현
- 자동으로 충전되지 않을경우, [충전하기] 버튼을 클릭하면, 충전처리 함수 charge_points() 를 호출하여 충전처리한다.
- 충전하기 프로세스가 완료되면  charges테이블에 충전내역이 생성된다.

id, user_id, usdp_amount, tron_address, usdt_amount, created_at



결제는 보유한 포인트(point)로 결제한다. 
포인트는 테더를 usdt로 디파짓하면, 그에 상응하는 usdt포인트(point)로 충전되어 결제에 활용된다.
각 상품은 products 테이블에 저장되어 있다.
id 상품명, 상품코드 가격 지급주식  지급토큰 

-------




----

[트론지갑, 테더로 입출금 처리]
회원이 가입시, 또는 개인정보수정에서
트론주소 입력항목에, 각 유저별로 기존에 트론주소를 갖고 있으면 회원정보에서 트론주소입력란에 입력하여 정보를 기록한다. 주소가 입력되면 이 주소를 조회해서 나의보유 트론수와 현재시세를 조회해서 표시해준다.
만약 트론주소가 없으면  [트론주소 생성하기]를 누르면, 자동으로 트론주소가 생성된다.
이때 내부적으로는  생성된 지갑주소와 개인키는 tronwallet 테이블에 저장되고, 여기서 하나씩 회원이 가입되면 매칭해주는 방식으로 진행하라.

유저의 트론주소 활용. :
1) 입금여부 체크하는데 사용, 입금이 확인되면  해당되는 상품의 구매가 완료된다.
2) 출금시 활용:  포인트로 쌓여진 수수료등을 출금할때, 해당 트론주소로 출금해준다.
출금시-출금요청수량, 수수료 5%를 공제하고 실제 수량만큼만 , 지정된 주소로 전송한다.

이 과정에 필요한  <회원등록 페이지>와  <출금신청 페이지>를 구성하라. 필요한 관련화일이 있으면 생성하되, 가능한 한페이지에서 실행되도록 하라. 
주석을 충실히 첨부하고. 필요한  mySQL DB SQL도 작성하라
작성언어 : html,css.js, php, botstrap,fontawesome등 .. 관련 cdn라이브러리 활용하라.

트론주소에 입력된 수량,  트론  및 테더 (TRC20)  의 수량과 현재시세를 적절한 cdn api등을 통해 시세를 불러와서 병행표시하라. 기준은 usdt 기준으로 매출을 관리한다. 수수료등을 위해 트론의 가격도 시세정보에 반영해야 하므로 가격을 알려주는 곳을 연동해서 나타내야 한다. 함께 구현해라.


후원인 검색,  추천인 검색  이 두가지는 매우중요하다.
<후원 조직도>와 <추천조직도> 그릴때도 중요하고,  이 조직도에 따라, <추천수당>과  <직급수당>을 계산하기 때문이다.

[후원인 검색]
회원 아이디를 입력후 [후원인검색] 버튼 클릭시, 후원인을 users테이블에서 조회하고, 후원인 아이디가 존재하면 그 사람의 "후원인 아이디(성명)을 표시하고, 이 검색된 후원인이 현재 몇명의 피후원인을 갖고 있는지를 체크한다. 후원인은 바이너리조직이므로 그 조회된 후원인 아이디를 후원인으로 하고 있는 사람의 수가 2명이 되었다면, 후원인이 2명이므로 추가할수 없다. 다른 아이디를 후원인으로 하라는 메세지를 showModal("후원인 추가 불가", "후원인 추가 불가 메세지") 모달에 출력해준다.
[후원조직도 검색]
회원 아이디를 입력후 [후원조직도검색] 버튼 클릭시, 후원조직도를 조회하고, 후원조직도를 표시한다.
왜냐면 후원조직도를 보면서, 후원인 아이디를 찾아서 후원인으로 등록할수 있기 때문이다.

[추천인검색]
회원 아이디를 입력후 [추천인검색] 버튼 클릭시, 추천인을 users테이블에서 조회하고, 추천인 아이디가 존재하면 그 사람의 "추천인 아이디(성명)을 표시하고, 이 검색된 추천인으로 "추천인으로 등록할수 있습니다."  추천인은 몇명을 해도 상관없이 등록할수 있다. 추천인은 바이너리가 아니므로 숫자를 체크하지 않는다. 

후원인 검색과 추천인 검색은 users테이블에서 조회하고 표시하는것은 같으나, 후원인은 바이너리 조직이라는 것을 검사하여 누구든 2라인 이상 후원조직을 둘수 없다. 따라서 후원인은 2명이상 등록할수 없고, 추천인은 바이너리가 아니므로 여러명 등록할수 있으므로 숫자를 체크하지 않는다.


트론주소의 USDT(테더) TRC20유효성검사는 트론주소가 맞는지 안맞는지 검사하는 것이다. 
관련 cdn 라이브러리 활용하여 맞는지 안맞는지 검사하라. 유효성검사를 클릭하면 "유효한 주소입니다" 또는 "유효하지 않은 주소입니다" 메세지를 표시하라.

후원인 조직도를 표시한다.
현재 첨부된 join.php를 완전하게 수정하라.


1. 아이디 중복검색 오류:
아이디 조회  검색하는 입력값은 user_id값이다.. 중복확인 누르면, 입력된 아이디를 가지고, users테이블을 조회해서 user_id컬럼에 해당 user_id가  존재하면 "이미 가입된id입니다"라고 하든지,  입력안하면 "아이디를 입력해주세요" , 중복된 아이디가 없으면 "등록 가능한 id입니다." 이런 메세지가 나와야한다. 표시는 [중복확인]버튼 누르면 하단에 메세지가 노출되어야 한다.  

2. [후원인조회, 추천인조회] 버튼시, 입력된 후원인조회와 추천인 조회에 사용되는 input값은 user_id이다.  
3. 후원인 검색
후원인 입력란에 user_id를 넣고 [후원인확인] 버튼 클릭시, users테이블의 user_id컬럼을 조회해서, user_id컬럼에 해당 조회하는 후원인이 있는지 없는지 체크하고, 있으면 그 후원인의 user_id를 가지고, 다시 sponsored_by 컬럼값을 검색하여, 그 후원인의 user_id가 sponsored_by 컬럼값에 안들어있는지, 한번들어있는지, 2번들어있는지 체크하여  몇번 들어있는지 파악한다.  
즉, 검색하는 후원인의 sponsored_by 컬럼에 몇명이 있는지, 있으면 그 후원인이 몇명의 피후원인을 갖고 있는지 체크하여 표시해준다.  

표시1 : "입력하신 user_id는 존재하지 않습니다. 다시 후원인 ID를 입력하세요." 
표시2: "홍길동(hong)님을 후원인으로 등록가능합니다." 
표시3 : "홍길동(hong)님은 2명의 후원인이 있어서 등록할수 없습니다. 다른 후원인을 선택하세요"    

 현재오류표시 : 회원가입이 최종 제출했을때, 오류가 표시되서, 다시 신청하고 입력해야 하기 때문에,
 바로 아이디 중복검색, 후원인, 추천인 검색등록 등의 각 입력폼하단에서 메세지를 표시해 줄것
 
 마지막 최종제출시 결과 및 메세지츨력은때 showModal()에 출력해주던지, 입력값 하단에 오류메세지 표시해주던지 그 입력칸에서 먼저 체크를 해줘라  

[추천인 user_id등록] 

추천인은 user_id를 입력받아 검색후, users테이블에서 user_id를 검색하여 존재하면, 그 사람의 성명(user_id)를 표시해주고, 그 사람의 user_id를 referred_by컬럼값에 저장한다. 

표시1 : 홍길동(hong)을 추천인등록가능 
표시2 : user_id님은 존재하지 않습니다. 다시 입력하세요. 
현재오류]  추천인을 검색하여 선택하여 등록하는 형식으로 되어 있으나, 그게 아니라그냥 회원 아이디 (user_id)입력하면, 검색하여 존재하면 그 사람의 성명(user_id)를 표시해주고, 그 사람의 user_id를 referred_by컬럼값에 저장한다.   

모두 완벽하게 수정한후, 필요한 추가 파일들을 모두 완성하여, 회원가입하기가 완벽하게 작동되도록 하라.  



--------------
당신이 25년차 전문가로서 위에서 제시한 코드들중에 생략되었거나 누락된 부분 아래사항을 완벽하게 채워넣고 완성하라.
나는 개발초보자로서 당신의 코드를 이해하지 못하고 그대로 코딩하는 것이 매우 어렵다. 따라서 당신이 코드를 완성하여 제공해주는 것을 기대한다.

[1] 포지션 추가, 회원가입 (join.php)수정

당신이 직급수당 계산함에 있어,, 좌실적, 우실적을 위해 새로운 users테이블에 position컬럼을 추가하였다.  이부분이 회원가입에서 어떻게 반영해야 하는지, ui/ux와 실제 users테이블에 저장하는 부분을 잘 적용해야 하는게 매우 중요하다.
1) 현재 : 현재의 join.php 코드를 보면, 후원인을 조회하여 2명이 다 채워지지 않으면 좌,우상관없이 랜덤하게 후원인으로 등록되고 있고,,2명이면 바이너리이므로 더이상 후원인으로 등록할수 없고, 그에 따른 메세지를 표시한다.
2) 수정 : 후원인 검색후 아직 후원인이 없으면  [ㅇ좌,ㅇ우] 선택 라디오 버튼이 나타남.(당신이 더 좋은 제안이 있으면 그방식으로) 좌,우선택창이 나타남. 그중 하나 선택하면 후원인 "홍길동(Hong)-좌측"에 등록가능!  하고 메세지 표시한다.
 만약 후원인이 이미 1명이 있어 "좌" 또는 "우"가 선택되어 있다면, 그 후원인은 자동으로 남은 "좌"또는 "우"가 선택되기 때문에 라디오버튼 선택이 필요없이 자동으로, 좌측이 등록되어 있다면, 자동으로 position은  후원인 "홍길동(Hong)-우측"에 등록가능!  하고 메세지 표시한다.

 이 후원인 좌,우 선택부분이 기존 레이아웃 ui/ux에 이질감이 없도록 매우 정교하게 고퀄리티로 
디자인하라. 
[입력칸][후원인검색버튼] [ㅇ좌ㅇ우] 이런 레이아웃으로  1줄로 연결되어 나타나야 한다. 

좌우등록 수정후, 실제 회원등록기능이 기존에 정상적으로 되었던 부분이 훼손되어서는 안된다. 수정후 정상작동부분까지 확인하라.

[2]save_company_state()
//save_company_state 함수 구현이 빠진 부분이 있어서 이부분을 모두 제대로 완성하여 채워넣으세요.  admin_company.php에 표시될것을 점검하여 모두표시되도록 완벽하게 작성하라.

function save_company_state($conn, $date) {
    // 필요한 통계 데이터 계산
    // 예시로 몇 가지 데이터만 계산
    $stmt = $conn->prepare("SELECT COUNT(*) as new_members FROM users WHERE DATE(created_at) = ?");
    $stmt->bind_param("s", $date);
    $stmt->execute();
    $new_members = $stmt->get_result()->fetch_assoc()['new_members'];
    $stmt->close();

    $stmt = $conn->prepare("SELECT SUM(total_amount) as company_sales FROM orders WHERE DATE(created_at) = ? AND status = 'completed'");
    $stmt->bind_param("s", $date);
    $stmt->execute();
    $company_sales = $stmt->get_result()->fetch_assoc()['company_sales'];
    $stmt->close();

    // 기타 필요한 데이터 계산 (여기서는 생략)

    // 회사 일일 통계 저장
    $stmt = $conn->prepare("INSERT INTO company_state (date, new_members, company_sales) VALUES (?, ?, ?)");
    $stmt->bind_param("sid", $date, $new_members, $company_sales);
    $stmt->execute();
    $stmt->close();
}


[3] 트론 테더 입출금 관련 종합적 체크 요망.(중요)
TronGrid API를 사용한 TRON 및 USDT 입출금 구현하는 것으로 확정. 
초기에 당신이 php컴포저 설치방식등으로 제안한 코드들이 혼재했지만. trongrid cdn api를 통해 처리하는 것으로 확정. 
따라서 당신이 제안한 테더 입출금 과정이 정확하게 최종 확정되어 문제없음을 최종점검해줘야 한다. 생략되거나 누락없이 완벽한 코드들이 모든 페이지에서 완료되어야 한다.

[당신이 위에서 제안한 코드- 전체를 한줄한줄 점검해서 최종로직에 접합한지 확인요망]
1) functions_tron.php
2) deposits.php 구현 (충전하기 페이지)
3) admin_deposits.php 구현 (관리자 입금 내역 관리 페이지)
4) withdrawals.php 수정 (출금 신청 시 TRX 잔고 확인)
5) admin_withdrawals.php 구현 (관리자 출금 신청 관리 페이지)
6) admin_dashboard.php (관리자 트론/테더 계정 대시보드)

위의 각파일은 TronGrid방식 cdn 으로 처리할때, 당신이 제시한 파일들인데 다시한번 정밀체크하여 최종버전인지 각파일의 완성,미완성 등의 상태를 체크하고 최종버전을 완료하라.  생략하거나 누락하지말고 전체코드로 최종버전을 완성하라.

<기본체크>
기존의 입출금 처리 로직을 한번더 체크해서 제대로 구현되었는지 체크하라.

1. 회사의 트론계좌에 트론,테더가 입금될때, 회사트론주소 입금된 내역에서, 송금된 회원여부를 트론주소로 구분하여 자동으로 그 특정 회원의 입금여부를 파악하여 트론지갑주소, 테더금액 ,TXn등을 자동으로 인식해서 deposits테이블 컬럼값에 저장하고, 회원에게는 포인트로 충전해준다. users테이블에 point 내역도 업데이트 해준다. 
deposits테이블에 모든 테더관련 정보를 입력한다.


2.이를 위해, 회원페이지에서는 [충전하기]페이지를 통해, 자신의 From 트론주소를 입력해서, From amount 즉, 송금할 테더수량과 자신의 트론주소를 입력해서 전송했을때, 이 회원의 트론지갑주소가 고유의 값으로 인식해서, 회사 트론지갑주소 입금내역에서 이 고객의 트론주소로 입금한 내역이 있을경우, 이를 deposits테이블에 저장하고, 고객은 충전내역에서 관련정보와 "충전완료" 를 표시해준다. 


3. 또한 회사의 트론주소계정에 입금되면 자옫으로 주식계정(48%), 수당지급을 할 마스터계정(52%)로 분배하여 자동송금한다.
이에 관련된 별도의 테이블로 테더분배내역 관리 테이블을 별도로 생성하여 관리한다. 
여기컬럼에는 날짜,From입금주소,From입금금액, To주식계정금액(48%), To마스터계정금액(52%),전송TXN_stock, 전송TXN_master 등이 있다.


3. 회원이 출금신청 페이지도 기존 지시사항을 한번더 체크해서 제대로 구현되었는지 체크하라.

[출금하기 절차]
1) 회원은 <출금신청페이지>withdrawals.php에서 자신이 보유한 USDP(point)를 USDT로 출금요청할수 있다.
2)즉, 출금신청페이지에서 회원이 "출금요청금액"과 입금받을 "트론주소"를 입력하여 신청한다.
3)일단 회원이 출금신청을 하면 withdrawals테이블에 회원의 출금신청내역이 생성된다. 
4)관리자는 출금신청내역을 확인하여 출금처리를 수동으로 개별적으로 처리한다. 출금신청은 매일 한국시간 9시부터 5시까지 신청된 내역만 처리한다. 이후 신청은 익일 처리한다. 관리자페이지에서 신청자를 선택하여 일괄 처리할수 있다. 
5)리치클럽 마스터계정에서 회원이 신청한 금액과 신청한 트론주소로 해당하는 USDT를 회원이 지정한 트론주소로 송금한다.
이때 "withdrawals"테이블에 출금처리 내역이 생성된다. 처리결과와 출금수수료3%공제도 함께 기록된다.
또한 users테이블에 회원의 point 잔액을 업데이트 한다.
6)회원들은 자신의 출금신청 페이지 하단의 출금신청내역 리스트에서, 자신이 출금신청한 USDT정보를 확인할수 있다.
*(user_id, 출금신청일, 출금신청자, 출금신청금액, 출금수수료, 실제출금금액, 송금트론주소, 트랜젝션,  처리일자, 처리결과)
처리결과는 "출금처리중, 출금처리완료, 출금처리실패" 중 하나이다.


<관리자 페이지>에서는 admin_withdraw.php 페이지에서 출금신청내역을 확인하고 출금처리를 할수 있다.
*(user_id, 출금신청일, 출금신청자, 출금신청금액, 출금수수료, 실제출금금액, 송금해줄트론주소, 트랜젝션,  처리일자, 처리결과, 출금처리하기 버튼)
*출금처리하기 버튼을 클릭하면 모달창이 뜨고, 거기에서 출금주소,출금금액,수수료,실출금액 등 정보가 한번더 표시되고, 출금하시겠습니까? 버튼 클릭시 출금처리 함수 withdraw_points() 를 호출하여 출금처리한다.


----
sponsored_by 필드 보장:

모든 회원은 반드시 상위 회원(sponsored_by)을 가져야 합니다.
후원인은 이미 등록된 회원 중에서 선택합니다.
좌우 배치 규칙:

각 후원인은 최대 2명의 하위 회원(1명 좌측, 1명 우측)을 가질 수 있습니다.
position이 left와 right가 모두 차 있으면 새로운 하위 회원을 배치할 수 없습니다.

sponsored_by 필드가 NULL이 될 수 없다.
각 회원은 정확히 1명만의 후원인을 가져야 한다.
각 후원인은 최대 두 명의 하위 회원(좌/우)만 가질 수 있다.
position 필드는 left 또는 right로 반드시 지정되어야 한다.


1. 모든 회원은 자신을 후원하는 사람이나 추천해준 상위 회원이 있다.
2. 회원이 등록할때 먼저 상위사업자중 후원인을 선택한다.  그 사람의 좌측, 또는 우측에 배치된다.
만약 상위사업자가 이미 좌,우에 배치가 되었다면, 다른 임의의 사람을 선정해서 좌측,또는 우측에 배치된다.
즉, 후원인이 2명이 이미 되어있다면 ,, 신규등록하는 사람의 후원인은 2명이 안된  임의의 선등록된 사람의 좌측 또는 우측이다.  이거 이해되냐? 근데 너가 실제 데이터를 보면 먼저 등록된 사람 3명을 선정하거나.. 등록된 회원의 후원인이 존재하지 않는 null값이 존재하는등 엉망이다.
3. 추천인도 마찬가지다. 모든 회원은 자신을 추천해준 상위사업자를 갖는다. null값이 될수 없다.
추천인이 되는 그 상위사업자는 몇명이 되어도 상관이 없다. 추천인이 되는 선등록 사업자는 여러명의 추천을 할수 있다. 바이너리 제한이 추천인에게는 없다. 이게 이해되냐? 모든 회원은 추천해준 사람이 있으니 그 추천해준 사람의 아이디를 referred_by에 저장해야 된다.

요구사항
모든 회원은 referred_by와 sponsored_by가 NULL일 수 없다.

referred_by는 특정 회원이 새로운 회원을 추천했음을 의미한다.
sponsored_by는 바이너리 트리 구조상 해당 회원의 상위 후원자를 지정한다.
바이너리 트리 규칙을 따른다.

각 회원은 sponsored_by에 의해 정확히 한 명의 상위 후원자가 있으며, 한 후원자는 최대 2명의 하위 회원(left, right)만 가질 수 있다.
회원 등록 시 후원자를 할당하는 로직

새로 등록된 회원의 sponsored_by는 기존 회원 중에서 후원 가능(left 또는 right에 빈 자리 있음)한 회원 중 하나로 자동 지정된다.
후원자가 이미 좌/우 모두 배치된 경우, 다른 후원자를 찾아서 지정한다.
추천인 규칙

referred_by는 새로운 회원 등록 시 선택된 상위 사업자를 저장하며, 추천인은 여러 명을 추천할 수 있다.

수정 로직 요약
후원인 설정

자신 이전에 등록된 회원들 중에서 좌/우 포지션이 비어있는 회원을 선택합니다.
좌/우 포지션이 모두 찬 회원은 선택되지 않습니다.
추천인 설정

자신 이전에 등록된 회원들 중에서 랜덤하게 추천인을 선택합니다.
좌/우 포지션 설정

후원인의 좌/우 포지션을 확인하여 비어 있는 위치에 배치합니다.

후원인 설정:

자신보다 이전에 등록된 회원 중 좌/우 포지션이 비어있는 회원을 우선적으로 선택합니다.
추천인 설정:

자신보다 이전에 등록된 회원 중에서 랜덤하게 추천인을 선택합니다.
좌/우 포지션 설정:

후원인의 좌/우 포지션을 확인하여 비어있는 쪽으로 설정합니다.
관리자 예외 처리:

id = 1인 경우, 추천인 및 후원인 설정을 제외합니다.




[정산하기 settlement.php 페이지 구현]

orders테이블에 있는 모든 주문내역을 조회하여 정산처리하는 페이지를 구현하라. 

기간설정: [  ]~[  ] [정산하기]

정산기간동안의 주문내역을 조회하여, 아래의 정보를 정산처리하는 페이지를 구현하라.
기간이 설정되면 그 기간안에 정산할때, 1일단위로 아래의 순서대로 수당을 계산하고 해당되는 모든테이블에 관련 정산결과를 업데이트한다.
정산시 아래의 순서대로 정산처리를 한다.
수당의 계산을 선택하여 진행할수 있도록 선택하는 부분을 구현하라.

1. 추천수당 계산
2. 직급수당 계산
3. 센터수당 계산
4. 회원들의 실적 업데이트 및 직급 승급 계산
5. 회사 일일 통계 저장

오더주문건을 하나씩 해당기간의 주문건을 불러와서 추천수당, 직급수당, 센터수당 계산을 진행하는데, 
status="completed" 이고, status_paid가 pending인 주문건만 계산한다. 순서대로 불러와서 추천수당, 직급수당, 센터수당 계산을 진행한다.

정산의 경우, 정산진행상태를 표시한다.
2024년10월23일 주문정보 불러옴, 추천수당 계산중, 직급수당 계산중, 센터수당 계산중, 회원들의 실적 업데이트 및 직급 승급 계산중, 회사 일일 통계 저장중 등의 상태를 표시한다. 2024년 10월23일 정산이 완료됨.
functions_bonus.php 파일에 구현된 각 수당, 직급, 각종 정산과정을 중간중간에 진행과정을 메세지로 표시해준다.
추천수당은 상품주문단계에서 주문이 완료되면 자동으로 계산되어 수당지급 테이블에 저장된다. 따라서 정산시에는 디폴트값은 비선택이다. 특별히 재정산을 해야할때이니 주의한다.



아래의 초기 정산초안 버전을 참조하되, 초기 초안 버전은 추천수당 계산만 구현된 상태이다. 직급수당, 센터수당, 회원들의 실적 업데이트 및 직급 승급 계산, 회사 일일 통계 저장 등의 과정을 추가하여 완성하라.
모든 과정을 전체적으로 당신은 전문가이니 고려하여 모든 과정을 꼼꼼히 고려하여 , 정산하기 코드를 완성하라. 절대 놓치거나 오류가 발생하지 않도록 DB구조 테이블 구조등을 꼼꼼히 체크하여 완성하라.

<?php
// settlement.php

require_once __DIR__ . '/config.php';
require_once __DIR__ . '/functions_bonus.php';

$conn = db_connect();

// 정산 날짜 설정 (오늘 날짜)
$date = date('Y-m-d');

try {
    $conn->begin_transaction();

    // 추천수당 계산
    $stmt = $conn->prepare("SELECT id FROM orders WHERE created_at BETWEEN ? AND ? AND status = 'completed' AND paid_status = 'pending'");
    $start_time = $date . ' 00:00:00';
    $end_time = $date . ' 22:00:00';
    $stmt->bind_param("ss", $start_time, $end_time);
    $stmt->execute();
    $orders = $stmt->get_result()->fetch_all(MYSQLI_ASSOC);
    $stmt->close();

    foreach ($orders as $order) {
        calculate_referral_bonus($order['id'], $conn);
    }

    // 직급수당 계산
    calculate_rank_bonus($conn, $date);

    // 센터수당 계산
    calculate_center_bonus($conn, $date);

    // 회원들의 실적 업데이트 및 직급 승급 계산
    update_user_performance_and_rank($conn);

    // 회사 일일 통계 저장
    save_company_state($conn, $date);

    $conn->commit();
} catch (Exception $e) {
    $conn->rollback();
    error_log("정산 중 오류 발생: " . $e->getMessage());
}



[추천조직도]는
users 테이블에 있는 모든 회원들은 자신을 추천한 사람의 추천인id (referred_by) 필드가 있어서, 이 추천인을 추적 연결하여 기록되어 있는 사람들을 연결하여 그리는것이 추천조직도이다.

1. 중심노드는 로그인한 나의 아이디이다.
2. 나의 id를 중심으로 1대에 나의 user_id를 자신들의 referred_by 에 추천인으로 기록되어 있는 사람을 찾아 나의 1대에 배치한다.
3. 1대의 사람들 (즉,나를 referred_by로 저장한) 1대의 사람들의 각자들을 찾는다. 그래서 그 1대의 사람들의 user_id를  referred_by에 추천인으로 기록한 사람들을 찾는다. 그들이 나로 보면 2대이다.
4. 2대의 사람들을 각자들을 찾아서, 2대의 user_id를  referred_by에 추천인으로 기록한 사람들을 찾는다. 그들이 나로 보면 3대이다.
5. 3대의 사람들을 각자들을 찾아서, 3대의 user_id를  referred_by에 추천인으로 기록한 사람들을 찾는다. 그들이 나로 보면 4대이다.

이런식으로 끝까지 더이상 배치할 사람이 없을때까지 찾아서 배치하면 그게 추천조직도이다.

각 노드는 사각형으로 구성되며, 각 노드에는 users 테이블에 있는 모든 회원들의 정보를 표시한다.
아이디(login_id),
성명(name),
직급(rank),
본인실적(myAmount)

추천인(referred_by),아이디(login_id),성명(name),직급(rank),본인실적(myAmount) 등의 모든 정보는 users 테이블에 있는 모든 회원들의 정보를 불러와서 표시한다. 직급은 7단계이며,첨부된 이미지처럼 직급별로 색깔을 다르게 하라.

1.가능한 첨부한 이미지와 비슷한 레이아웃 형태의 추천조직도를 구현하라.
2.상단: 컨트롤박스위치 : 단계[  입력 ],아이디[ 입력 ] [검색버튼]  입력하여 검색할수 있게 컨트롤박스를 고정으로 둔다.
3.하단: iframe 형태 상단을 침범하지 않으며, 이곳에 조직도가 표시되고, 손가락으로 확대,축소,이동이 가능하다.
4.확대축소는 전체조직도가 형태를 유지하면서 크기가 확대,축소,이동된다.

첨부된 샘플 조직도코드를 참조하라.이는 첨부된 이미지를 구현하는 코드이다. 여기는 asp로 구현되어 있으니 php로 구현하라.
샘플코드는 전체구성 페이지 코드와 페이지속 하단 프레임속의 코드를 둘다 첨부하였다.
cdn 라이브러리를 사용하고 있으니, 최대한 모바일에 익숙하게 구현하라.


다음은 추천조직도를 구현하기 위한 DB구조이다. 모든 회원들은 자신을 추천한 사람의 추천인id (referred_by) 필드가 있어서, 이 추천인을 추적 연결하여 기록되어 있는 사람들을 연결하여 그리는것이 추천조직도이다.

//회원
CREATE TABLE users (
  id int(11) NOT NULL AUTO_INCREMENT,
  login_id varchar(50) NOT NULL COMMENT '로그인 ID',
  name varchar(50) NOT NULL COMMENT '이름',
  email varchar(100) NOT NULL COMMENT '이메일',
  phone varchar(20) NOT NULL COMMENT '전화',
  country varchar(20) DEFAULT NULL COMMENT '국적',
  rank varchar(10) NOT NULL DEFAULT '회원' COMMENT '직급',
  referred_by int(11) DEFAULT NULL COMMENT '추천인 (referrer id)',
  sponsored_by int(11) DEFAULT NULL COMMENT '후원인 (sponsor id)',
  position enum('left','right') DEFAULT NULL COMMENT '좌우 위치',
  point decimal(15,4) DEFAULT NULL COMMENT '포인트충전',
  usdt decimal(15,6) DEFAULT NULL COMMENT 'usdt(테더)',
  stock int(11) unsigned DEFAULT NULL COMMENT '주식수',
  token decimal(15,2) unsigned zerofill DEFAULT 0000000000000.00 COMMENT '토큰지급량',
  myAmount decimal(15,2) DEFAULT 0.00 COMMENT '본인 누적 구매 금액',
  referral_count int(11) DEFAULT 0 COMMENT '직접 추천한 회원 수',
  left_amounts decimal(15,0) DEFAULT 0 COMMENT '촤실적',
  left_members int(11) DEFAULT 0 COMMENT '좌인원',
  right_amounts decimal(15,2) DEFAULT 0.00 COMMENT '우실적',
  right_members int(11) DEFAULT NULL COMMENT '우인원',
  commission_total decimal(10,2) DEFAULT 0.00 COMMENT '수수료총액',
  bonus_referral decimal(10,2) DEFAULT 0.00 COMMENT '현금포인트',
  bonus_rank decimal(10,2) DEFAULT 0.00 COMMENT '마일리지포인트',
  bonus_center decimal(10,2) DEFAULT 0.00 COMMENT '센터수당',
  referral_code varchar(20) DEFAULT NULL COMMENT '추천인코드',
  referral_link varchar(255) DEFAULT NULL COMMENT '추천인링크',
  qr_code varchar(255) DEFAULT NULL COMMENT 'QR코드',
  organization varchar(100) NOT NULL COMMENT '소속',
  password varchar(255) NOT NULL,
  reset_token varchar(100) DEFAULT NULL,
  reset_token_expires datetime DEFAULT NULL,
  birth varchar(50) DEFAULT NULL COMMENT '생년월일',
  address varchar(200) DEFAULT NULL COMMENT '주소',
  tron_address varchar(100) DEFAULT NULL COMMENT '트론주소',
  stock_account varchar(100) DEFAULT NULL COMMENT '삼성증권계좌',
  is_center tinyint(1) DEFAULT 0 COMMENT '센터장인지 여부',
  status enum('active','inactive') DEFAULT 'active' COMMENT '활성화,비활성화',
  created_at timestamp NOT NULL DEFAULT current_timestamp() COMMENT '등록일',
  PRIMARY KEY (id),
  UNIQUE KEY login_id (login_id),
  KEY referred_by (referred_by),
  KEY fk_users_sponsored_by (sponsored_by),
  CONSTRAINT fk_users_referred_by FOREIGN KEY (referred_by) REFERENCES users (id),
  CONSTRAINT fk_users_sponsored_by FOREIGN KEY (sponsored_by) REFERENCES users (id)
) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci

다크모드,고품질,디자인의 일관성,php,mysql,javascript,jquery,css,html,bootstrap,cdn,모바일 등을 고려하여 오류없이 완성도있게 구현하라.
당신은 전문가로서 이러한 추천조직도를 수없이 구현해 봤을것이다. 따라서 당신의 지식을 총동원해서 가장 오류없이 고퀄리티 고품질의 추천조직도가 되게 구현하라. 

--------------------------------
[후원조직도]는
users 테이블에 있는 모든 회원들은 자신을 후원한 사람의 후원인id (sponsored_by) 필드가 있어서, 이 후원인을 추적 연결하여 기록되어 있는 사람들을 연결하여 그리는것이 후원조직도이다. 바이너리조직이므로 좌,우로 배치되며 2명이상은 될수없다.

1. 중심노드는 로그인한 나의 아이디(user_id)이다.
2. 나의 id를 중심으로 1대에 나의 user_id를 자신들의 sponsored_by 에 후원인으로 기록되어 있는 사람을 찾아 나의 1대에 좌,우에 배치한다.

3. 1대의 사람들 (즉,나를 sponsored_by로 저장한) 1대의 사람들의 각자들을 찾는다. 그래서 그 1대의 사람들의 user_id를  sponsored_by에 후원인으로 기록한 사람들을 찾는다.  그들이 나로 보면 2대이다.
4. 2대의 사람들을 각자들을 찾아서, 2대의 user_id를  sponsored_by에 후원인으로 기록한 사람들을 찾는다. 그들이 나로 보면 3대이다.
5. 3대의 사람들을 각자들을 찾아서, 3대의 user_id를  sponsored_by에 후원인으로 기록한 사람들을 찾는다. 그들이 나로 보면 4대이다.

이런식으로 끝까지 더이상 배치할 사람이 없을때까지 찾아서 배치하면 그게 후원조직도이다.

각 노드는 사각형으로 구성되며, 각 노드에는 users 테이블에 있는 모든 회원들의 정보를 표시한다.
아이디(login_id),
성명(name),
직급(rank),
본인실적(myAmount)

후원인(sponsored_by),아이디(login_id),성명(name),직급(rank),본인실적(myAmount) 등의 모든 정보는 users 테이블에 있는 모든 회원들의 정보를 불러와서 표시한다.
첨부한 이미지와 같은 레이아웃 형태의 추천조직도를 구현하라.
상단: 컨트롤박스위치 : 단계[  입력 ],아이디[ 입력 ] [검색버튼]  입력하여 검색할수 있게 컨트롤박스를 고정으로 둔다.
하단: iframe 형태 상단을 침범하지 않으며, 이곳에 조직도가 표시되고, 손가락으로 확대,축소,이동이 가능하다.
확대축소는 전체조직도가 형태를 유지하면서 크기가 확대,축소,이동된다.

조직도는 샘플코드를 참조하였는데, 여기는 asp로 구현되어 있으니 php로 구현하라.
전체페이지 코드와 프레임속의 코드를 둘다 첨부하였다.
cdn 라이브러리를 사용하고 있으니, 최대한 모바일에 익숙하게 구현하라.




특정회원의 아이디를 입력하면,  
조회할 회원아이디 : [   ]
조회기간 [  ]~[  ][검색] 하여

1) 본인의 누적매출:
2) 직접추천인수:
3) 좌실적:
4)우실적:
5)좌측회원수:
6)우측회원수:
7)소실적:
8)직급:


직급승급에 필요한 정보를 계산하고 조회할수 있는 별도의 페이지를 만들려고 한다.
즉, 회원의 승급여부 조건을 달성했는지 여부를  별도의 페이지를 만들어 각 테이블에 저장하지 않고,화면에서 조회만 할려고 한다.
주요로직이 functions_bonus.php에 있지만, 이게 맞는지 검증을 해야할 필요도 있어서 
함수내에 있는  update_user_performance_and_rank($conn)  함수를 분석하여, 각 테이블에 저장하지 말고, 화면에서 각각의 결과를 표시하도록 하라
직급을 위한 조건에 맞는 값을 얻도록 별도의 함수를 포함한 한장의 페이지를 만들어라. 
즉,functions_bonus.php 는 내부적으로 계산하고 각 테이블에 업데이트하게 되어있어 실제로 각회원이 어떤값을 어떻게 계산되는지 알수가 없어서 따로 페이지를 만들어 직접 표시하는게 필요하다.
주요 페이지는 첨부한 calculate_bonus.php를 참조하여 레이아웃을 참조하고, 화면에 진행결과를 표시하라.




functions_bonus.php 는 당신이 작성한 수당계산에 관련된 모든 로직을 함수들을 저장한 파일이다.
calculate_bonus.php 는 이 functions_bonus.php의 각 수당함수를 호출하여,선택적으로 기간을 정해 마감을 진행하는 컨트롤 페이지이다.
실행결과 
1) calculate_bonus.php 에서 추천수당을 선택하여 실행결과, 추천수당 계산과정은 정확하게 맞는다. 따라서 functions_bonus.php 속에서  calculate_referral_bonus (추천수당)계산함수는 정확히 호출되어 정확한 수당계산을 하는것으로 보인다.(추가수정필요없음)

2)문제는 functions_bonus에서 "직급수당"함수가 계산이 맞는지를 확인할수가 없어서, 즉, 컨트롤페이지 calculate_bonus.php 에서 직급수당을 선택한 후 실행하면 제대로 결과가 나오지 않는것같다. 즉,functions_bonus.php함수내에서 calculate_rank_bonus(직급수당) 함수 호출했을때, 직급수당 로직과 절차가 맞는지 확인할 수가 없다. 
3)그래서 클로드의 도움을 받아 직급수당관련부분만 따로 작성을 한 "직급수당관련함수.php"만을 따로 로직과 계산함수를 작성했다. 하지만 이것도 맞는지 알수가 없다. 그래서 모든 화일을 첨부할테니 당신이 25년차 개발전문가로서 이 코드를 참고하고 보완할 부분이 있으면 발췌하여 완성된 functions_bonus.php 함수를 완성하라.

4) 직급수당이 올바로 계산되려면, 직급승급계산 로직이 정확하여야 하므로 직급승급 관련만 체크하고자 직급승급여부를 확인하는 rank_analysis.php도 작성을 해서 기간을 정해 실제 승급로직에 맞게 승급하는지를 확인해 보기위해 작성하여 실행해 보았다.
이안에도 직급승급을 위한 본인실적조건,직접추천한추천인수, 좌실적,우실적중 소실적조건 등 승급에 필요한 조건이 functions_bonus.php에서도 있지만 확인할수가 없어서 이부분만 별도로 rank_analysis.php페이지를 만들어 테스트해보는데, 이조차도 관련로직과 함수가 맞는지 모르겠다.

문제는 functions_bonus.php 속에 직급수당계산과, 직급 승급조건 계산 하는게 실제 맞는지 검증할 길이 없어서 계속 방법을 찾는것이다.

5) 당신이 제시한 functions_bonus.php 내의 추천수당은 맞으니, 직급수당, 추천수당이 맞는지, 당신은 개발전문가로서 특히 직급수당이 맞는지 유사코드인 "직급수당관련함수.php"와 "rank_analysis.php"를 정밀하게 비교하여 보완해야 할 부분이 있으면 발췌하여 완성하라.
그리고 완성된 functions_bonus.php 함수를 활용하여 컨트롤페이지 calculate_bonus.php도 올바로 반영하여 수정하고, rank_analysis.php도 올바로 반영하여 각각 직급수당, 직급승급에 관련된 확인을 할수있도록 정밀하게 검토하고 수정하라.  결국 핵심은 functions_bonus.php의  최종 완성본을 완성하라.  수정이 필요한 경우, 원인과 수정전후에 대해서 자세히 설명하라.

아래에 관련 코드를 첨부하였다. 이 코드를 참조하여 완성하라.

functions_bonus.php 코드 첨부


직급수당관련함수.php 코드 첨부


rank_analysis.php 코드 첨부


1."직급승급" 조건 관련 조건은 재검토 하지 않아도 되는가? 정확한지 체크하라. 정확하게 해서 functions_bonus.php 에 반영하라.
2."센터수당"관련도 첨부된 코드를 참조하여 보완이 필요한지 살펴보라. 그래서 정확하게 해서 functions_bonus.php 에 반영하라.
functions_bonus.php가 정확해야 나머지 페이지들이 정확하게 동작할수 있다.

3.위 첨부된 컨트롤페이지 calculate_bonus.php 에서 추천수당, 직급수당, 센터수당 계산과정이나 처리결과가 정확한지 체크하라.
4.위 첨부된 직급승급을 체크하는 rank_analysis.php 페이지에서 조건 관련 조건을 정밀하게 검토하여, 이 페이지가 올바른 결과를 표시하도록 함께 보완하고 수정하라.

수정이 필요한곳은 원인과 전후를 비교하여 설명하라.


"추가코드-직급,센터수당관련.php" 코드 첨부된참조하라.


--

현재 코드는 레이아웃도 엉망이고 조직도도 또 안나타나고.. 미칠지경이다..

그래서 예전에 코드 수정하라고 당신에게 했던 초기 코드를 다시 첨부하고, 그당시 레이아웃 수정하라고 캡쳐해서 올린 며칠전것을 다시 올리니,,거기서 부터 다시 출발하는게 오류를 줄일수 있을듯하다.  첨부한 것은 마지막 정상적으로 되던 코드에서 레이아웃 수정하라고 했을때 코드이다. 이게 되었다가 당신이 엉망으로 만들엇다.. 

다시 예전으로 돌아가 .. 오류가 없이 조직도는 표시되엇고,, 레이아웃만 좀 수정하고 ㅡㅡ검색기능과 버튼 기능들 고치라고 했다. 여기서 부터 다시 출발하자.

현재차트 chart.php,  예전 chart.php는 카피해서 paste하겟다.  예전걸 중심으로 오류나 레이아웃을 보강하라. 최근 며칠간 한것은  레이아웃이나 기능이나 조직도 조차도 나타나지 않으니..  비교하여 정상기능과 레이아웃을 만들어라.

원인을 찾고 그 원인을 어떻게 수정해야 하는지도 설명하라.





--
notice.php
notice.php 공지사항과 공지사항을 관리할 admin_notice를 만들고자한다.
회원용 notice.php는 제목, 내용, 작성일, 게시자, 조회수 등의 필드를 가지고 있으며, 
관리자용 admin_notice.php는  관리자페이지에서는 공지사항을 등록,수정,삭제 할수 있으며, 작성시 유저들이 최종적으로 공지내용을 퀄리티있는 디자인으로 볼수 있게, 작성에 html cdn 라이브러리 등을 사용해 내용작성뿐만 아니라,  이미지추가,영상추가, 링크추가해서 각각 공지사항 게시판이 꽤 완성도 높게 만들어 보여주도록 하라. 
유저들페이지는 최근 공지사항이 제일먼저 내용본문이 나오고, 하단에는 공지사항 목록 리스트가 나오고 클릭하면 본문내용을 볼수 있게 한다.
목록은 제목과 작성일만 표시되고 제목을 클릭하면 본문내용을 볼수 있게 한다.
목록 밑에는  페이징을 표시  페이징[이전]1,2,3,4,5[다음] 버튼이 표시되고 페이지 번호가 표시되도록 한다.
공지사항은 때론 중요사항은 중요하게 보여주어야 하므로 중요공지사항 표시를 해야한다. 이것은 관리자페이지에서 중요공지사항 체크박스를 체크하면 표시되도록 한다. 그러면 주요공지가 본문표시 위에 모달창으로 요약되어 별도로 공지되도록 한다.
관리자페이지에서 적당한 크기의 카드이미지나 글을 작성하여 모달창에 올리면  중요공지내용은 본문게시외에도 모달창이 뜨도록 한다.

이와 같은 구조의 공지페이지를 만들어라, 이는 관리자페이지랑 함께 만들어야 한다.
디자인은 기존 다크모드 황금블랙 고급스러운 고퀄리티 디자인 일관성을 유지하라.
기본 게시판 기능이므로 오류없이 작성하라. 가능한 한페이지에서 모든기능이 구현되도록 하라.
그외 필요한 요소는 개발전문가로서 당신이 학습된것중 가장 트렌디하고 완성도 높은 디자인과 기능을 적절히 조정,추가,수정하여 매우 완성도있는 공지사항이 되게 하라.


<script src="https://cdn.jsdelivr.net/npm/tronweb@latest/dist/TronWeb.min.js"></script>

내 지갑으로 들어온 트트랜젝션을 5분에 한번씩 불러와서 내 디비에 저장한후, 그 디비에서 내가 정한 주소의 금액과 트랜젝션을 비교하여  별도로 저장하는방법과.
현재 자신들이 내 지갑주소에 usdt를 보내고,, 보낸 트론주소를 회사에 통보한다.
그 주소와 보낸금액을 디비에 저장한다.


--------------------------------
//충전

CREATE TABLE `deposits` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `amount_usdt` decimal(15,6) NOT NULL COMMENT '송금신청한 USDT 금액',
  `confirm_usdt` decimal(15,6) NOT NULL DEFAULT 0.000000 COMMENT '확인한 USDT금액',
  `amount_usdp` decimal(15,4) NOT NULL COMMENT '충전된 USDP 금액',
  `from_tron_address` varchar(100) NOT NULL COMMENT '송금한 트론 주소',
  `to_tron_address` varchar(100) NOT NULL COMMENT '회사 트론 주소',
  `transaction_id` varchar(100) NOT NULL COMMENT '트랜잭션 ID',
  `tronscan_link` varchar(300) DEFAULT NULL COMMENT '트론스캔링크',
  `status` enum('pending','completed','failed') DEFAULT 'pending' COMMENT '처리 상태',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp(),
  `processed_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `user_id` (`user_id`),
  CONSTRAINT `deposits_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci


[입금하기]
deposits 테이블에서 
1. 회원들은 회사지갑에서 충전할 금액을 위해, 자신들이 USDT를 예정금액(amount_usdt) 만큼 `from_tron_address` (자신들의 트론지갑주소)에서 회사지갑으로 `to_tron_address` (회사주소)로 송금을 신청한다. 
2. 각자가 자신들의지갑에서 회사지갑으로 보낸다.
3. 회사는 회원이 신청시 신청내용을 deposits테이블에 정보를 저장된다. 
4. 그리고 당신이 개발하여야 할 코드는 회사의 트론주소를 모니터링하다가, 회원의 주소(from_tron_address) 주소에서 회사지갑(to_tron_address)으로 송금이 되었는지 확인하는 코드를 작성하는것이다.
5. 만약 회사지갑주소에서 from_tron_address로 부터 오는서 해당 트랜젝션이 있으면, 
6. deposits테이블에 트랜젝션(transaction_id), 실제입금된 금액(confirm_usdt), 트론스캔링크(tronscan_link)를 조회해서 deposits테이블에 저장한다. 그리고 상태값은 status="completed" 완료일은 (processed_at)로 하여 해당충전건은 종료한다. 
7. users테이블의 points값을 누적하여 업데이트 한다.

이것을 5분에 한번씩 반복해서 확인하는 코드를 작성하라.
회사지갑주소에 5분에 한번씩 트랜젝션을 점검해서 입금된 것이 있다면 트랜젝션을 저장하는 것이다.
시간은 지정할수 있다.
또한 5분에 한번씩 확인하여 deposits테이블에 저장하고, users테이블의 포인트에 누적한다.

3분에 한번씩이든 이것은 지정하면 된다.


Trongrid.io API
c830d5ad-b752-4a4f-9247-30826e45a2c2

회사입금주소 : TMh8hp5sV27apvQSAALPfCVYjZpdzB1vZf
회사입금개인키 : 90bd7c6e14854fba363ea57d9452fefbaa652fa22c5cf27601d0d179598c8ee7


회사주소로 들어온 USDT는 5분에 한번씩 잔고의 63%를 마스터계좌로 보낸다.
마스터계좌 주소 : TECXxuTdgMNETyYndRkKYnM6KpH2DtwBty
마스터계좌 개인키 : 00ec30ba0e6aee95990e9cc28d2bee8a6c3322ac291f45cbace2ab5caeac1b58

마스터계좌는 앞으로 모든 회원들에게 수당을 지급하는 출금계좌이다.


회사주소에서 주식구매 계좌로 37%를 보낸다.
주식계좌 : TUCjrVPPgrCMYty8BdFN9hCUHxxhVEjDPQ
주식계좌개인키 : 5d77cec50cff5c9d0f99e71bc084cadc5a08e82e08adf669347378370547c0b8






//출금

CREATE TABLE `withdrawals` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `request_amount_usdp` decimal(15,4) NOT NULL COMMENT '출금 신청한 USDP 금액',
  `fee_percentage` decimal(5,2) DEFAULT 3.00 COMMENT '출금 수수료 (%)',
  `fee_amount` decimal(15,4) NOT NULL COMMENT '출금 수수료 금액',
  `actual_amount_usdt` decimal(15,6) NOT NULL COMMENT '실제 출금되는 USDT 금액',
  `tron_address` varchar(100) NOT NULL COMMENT '사용자의 트론 주소',
  `transaction_id` varchar(100) DEFAULT NULL COMMENT '출금 트랜잭션 ID',
  `tronscan_link` varchar(500) DEFAULT NULL COMMENT '트론스캔링크',
  `status` enum('pending','completed','failed') DEFAULT 'pending' COMMENT '처리 상태',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp(),
  `processed_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `user_id` (`user_id`),
  CONSTRAINT `withdrawals_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci




BSC주소생성  바이넨스스마트체인
API : WX9KE9S86IE93WAC2PXG59NTRPGFJ2XDU6

1. 회사메인주소(Rich_Main)
주소: 0xFAF0ab8dcBcDc1806A65119C8f59187499E4B910
개인키: c3f52eae589a4d169746400f9179b3ce383f7ab1743170a775cb939fa395be49

2. 마스터주소(Rich_Master)
주소: 0x4411a3d1F8B2ff41ebC32FCFC7dCB519CdF615DF
개인키: 784d8f222cb75af6eef70fd03065b4bd8825efd5c2673582c5755cd705bc11fe


3. 주식계좌주소(Rich_Stock)
주소  0x84DC618fbf323b42CDBf4672FC5EfEd4d284ad48
개인키 f836ffb432b39f82af3b66ae5dea6d61e11bd957c786e9b9310a4a4cac6a8e9d




거래소지갑은 회원들의 지갑과는 달라서, 랜덤하다. 그래서  금액입력, 주소입력 방식으로는 구별이 어렵다. 그래서 아예 회사주소로 usdt송금후 나온 트랜젝션 해쉬값을 입력받아 그 해쉬값을 통해서 회사 bsc계좌에 그 트랜젝션이 있으면, from, to, 금액, transaction_id, 트랜젝션링크, usdp, 와 users테이블의 point업데이트를 충전이 되었는지 확인하는 방식으로 한다. 


트랜젝션코드를 입력하였으므로,, 신청금액은 표시고 실제 트랜젝션에 의해 확인된 confirm_usdt가 우선적용되어 해당되는 usdp값이 충전되고, 마찬가지로 users테이블의 point값이 누적업데이트 된다.  이로직이 제대로 구현되는지 ..설명하고 어떤것들이 저장되고 업데이트되는지등의 절차를 deposits.php가 제출되고 난 이후의 절차 처리프로세스를 자세히 설명하고..
그럼에도 제출되어, 관련정보가 미처리될경우, 관리자페이지 목록에서는 모두처리된 결과들만 잇는게 아니고, 미처리되어 펜딩상태에 있는 신청건에 대하여 [입금확인]버튼을 만들어 뒤늦게라도 클릭하여 입금확인을 버튼을 눌러 개별적으로 관리 할수 있다. 



트랜젝션을 입력해도 왜 관련값을 불러오지도 못하고 업데이트도 못할까요? 혹시 간단히 cdn이나 라이브러리로  간단히 체크해볼수 있는수준인데..이걸 못불러오는 이유가 있나요?
" 트랜젝션해쉬"를 직접 DB에 입력해놨으니.. 이걸 bsc스캔에 입력해도 다 나오는것을 왜 못불러오죠? 사실 deposits.php 회원이 입금신청할때 트랜젝션을 입력하기 때문에 폼제출할때 아예 그 트랜젝션을 cdn으로든 호출해서 그결과값을 아예 디비에 저장해놓으면 더 나을듯.. admin_deposits.php는 관리상 디비에 저장되어 있는 정보를 불러와 표시하고.. 혹시 미처리된 부분만 별도로 처리해주는 버튼을 두고 호출하면 업데이트 되는 구조로 한다.




deposits.php에서의 처리 과정
1. 사용자가 입금 신청을 함
사용자는 입금 신청 폼에서 다음 정보를 입력합니다:
신청 금액(amount_usdt): 사용자가 송금한 금액 (표시용)
트랜잭션 해시(transaction_id): 송금한 트랜잭션의 해시 값
2. 서버에서 트랜잭션 정보 검증 및 저장
폼이 제출되면 서버는 다음을 수행합니다:

입력값 검증:

금액이 유효한지 확인 (최소 10 USDT 이상)
트랜잭션 해시 형식이 올바른지 확인
트랜잭션 중복 확인:

해당 트랜잭션 해시가 이미 데이터베이스에 있는지 확인하여 중복 처리 방지
트랜잭션 정보 조회 및 검증:

BSCScan API를 통해 트랜잭션 정보를 조회
트랜잭션이 성공적으로 처리되었는지 확인
트랜잭션이 USDT 전송인지 확인
토큰 전송 이벤트를 통해 실제 전송된 금액(confirm_usdt), 송신 주소(from_address), **수신 주소(to_address)**를 확인
금액 일치 여부 확인:

사용자가 입력한 금액(amount_usdt)과 트랜잭션에서 확인된 금액(confirm_usdt)을 비교
실제 입금된 금액(confirm_usdt)을 기준으로 USDP를 충전하므로, 신청 금액은 참고용이며 금액이 일치하지 않아도 실제 입금된 금액으로 처리됩니다.
데이터베이스 업데이트:

deposits 테이블에 입금 내역을 저장하고, 다음 정보를 포함합니다:
user_id, amount_usdt, confirm_usdt, amount_usdp, transaction_id, from_address, to_address, scan_link, status, created_at, processed_at
users 테이블의 point 컬럼을 confirm_usdt만큼 증가시킵니다.
3. 사용자에게 결과 전달
입금이 정상적으로 처리되었음을 사용자에게 알립니다.
입금 내역은 최근 입금 내역에 표시됩니다.


--

직접입력했을때 응답값은정상이다. 근데 왜 당신이 제시한 코드를 실행하면 "오류: BscScan에서 트랜잭션 정보를 가져올 수 없습니다." 이런 메세지를 내밷는거야.
실제
https://api.bscscan.com/api?module=account&action=tokentx&contractaddress=0x55d398326f99059fF775485246999027B3197955&address=0xFAF0ab8dcBcDc1806A65119C8f59187499E4B910&page=1&offset=100&sort=asc&apikey=WX9KE9S86IE93WAC2PXG59NTRPGFJ2XDU6

직접입력했을때 응답값

{"status":"1","message":"OK","result":[{"blockNumber":"43976805","timeStamp":"1731511151","hash":"0x800e63411b1e27f56d18c71d511a9c5906af0e3125c89f49ec0d619e2eba266b","nonce":"645367","blockHash":"0x380e474445c146ecb89f303c4225c215ec83dfb659e5082bbccbf2dab239602a","from":"0x9bb6a22da110c6c9bab745bcaf0ee142ee83af37","contractAddress":"0x55d398326f99059ff775485246999027b3197955","to":"0xfaf0ab8dcbcdc1806a65119c8f59187499e4b910","value":"100000000000000000000","tokenName":"Binance-Peg BSC-USD","tokenSymbol":"BSC-USD","tokenDecimal":"18","transactionIndex":"19","gas":"1000000","gasPrice":"0","gasUsed":"51615","cumulativeGasUsed":"1374458","input":"deprecated","confirmations":"6559"}]}

이렇게 정상적으로 모든 값들이 다 들어있는 응답값이 왔네요.. 여기서 필요한 것들이 
From주소, To주소 , Value값, 100usd, Hash값(이건입력받음),
그런데 이걸 불러와서 디비에 저장하는것을 며칠간 못하는 이유가 뭔가? 
그래서 그동안 하도 왔다갓다.. 수정하고 고치고 해서 엉망진창이 되어 버린 코드를 최종 다 다시 정리하라. 
1. deposits.php에서 회원들이 금액, 트랜젝션해쉬 값을 입력하여 회사에 폼을 제출한다.
2. 회사는 이 트랜젝션해쉬값을 가지고 폼이 제출되면 API를 호출하여 그 트랜젝션해쉬값이 가지는 실제값들을 deposits테이블에 디비에 저장한다. s그 받은 값을 실제값으로 해서 해당하는포인트를 충전학 users테이블의 point를 누적 업데이트 해준다. 마지막으로 상태를 status=completed 완료로 한다.

이과정이 전체이다. 따라서 트랜젝션해쉬값과 API값, 회사주소, 등으로 api직접호출해도 값이 나오니 이것을 잘 파싱해서저장하라.

당신께 부탁한다. 당신은 25년차 개발전문가이다.. deposits.php  금액, 해쉬값을 입력받아 처리하고, 혹시 처리 안된것은 일단 디비에 저장하고,, 관리자 페이지에서 수동으로 처리하도록 제대로된  완전히 다시 레이아웃을 구성하는거만 제외하고 완전히 새로 3개의 파일을 작성하라.
혹은 기능을 포함해서 2개만해도 되든지.. . deposits.php와 admin_deposits.php  제발 부탁한다 ..벌써 며칠째다.. 당신도 전문가가 아닌듯하다.
 


0---

1. deposits.php는 
고객이 입금 신청할 금액(amount_usdt)과 트랜젝션 해쉬값(transaction_id)을 입력후 입금확인버튼을 눌러 제출한다. 
여기서는 바로 신청값만 deposits테이블에 저장하고 메세지를 남기고 처리중이 뜬다.
"그러면 정상적으로 접수되었습니다. 네트워크 확인후, 충전됩니다." 라는 메세지를 남기고 일단 deposits테이블에 저장되고 ..그 결과를 불러와 deposits.php 하단에 표시된다. 이때 처리결과는 pending이므로 처리중이 뜬다.

테이블에 저장되는 값은 
user_id, amount_usdt, transaction_id, status, created_at 이다

2. 이후 입력된 고객의 "입금신청내역"이 하단에 표시되는데.. 아직 "처리중"상태이므로, 입력된 트랜젝션 해쉬값으로 회사주소로 입금되었는지 트랜젝션 해쉬값으로 조회하여 확인하는 작업이 필요하다.
이때 check_deposit()함수를 호출하여 회사주소로 입금되는지 확인하는 작업이 필요하다.
*당신이 이 함수를 작성하여 회사주소로 입금되는지 확인하는 작업을 완료하라.

3.TX 헤쉬값으로 확인하는 작업
나는 직접 입력하여 주소창에 넣어서 아래의 응답값을 받았다. 

(예시) 고객이 입력한 트랜젝션해쉬값 :0x800e63411b1e27f56d18c71d511a9c5906af0e3125c89f49ec0d619e2eba266b
회사주소 : 0xFAF0ab8dcBcDc1806A65119C8f59187499E4B910
BSC_API : WX9KE9S86IE93WAC2PXG59NTRPGFJ2XDU6
contractaddress : 0x55d398326f99059fF775485246999027B3197955

https://api.bscscan.com/api?module=account&action=tokentx&contractaddress=0x55d398326f99059fF775485246999027B3197955&address=0xFAF0ab8dcBcDc1806A65119C8f59187499E4B910&page=1&offset=100&sort=asc&apikey=WX9KE9S86IE93WAC2PXG59NTRPGFJ2XDU6

4.직접입력했을때 응답값은 다음과 같다.

{"status":"1","message":"OK","result":[{"blockNumber":"43976805","timeStamp":"1731511151","hash":"0x800e63411b1e27f56d18c71d511a9c5906af0e3125c89f49ec0d619e2eba266b","nonce":"645367","blockHash":"0x380e474445c146ecb89f303c4225c215ec83dfb659e5082bbccbf2dab239602a","from":"0x9bb6a22da110c6c9bab745bcaf0ee142ee83af37","contractAddress":"0x55d398326f99059ff775485246999027b3197955","to":"0xfaf0ab8dcbcdc1806a65119c8f59187499e4b910","value":"100000000000000000000","tokenName":"Binance-Peg BSC-USD","tokenSymbol":"BSC-USD","tokenDecimal":"18","transactionIndex":"19","gas":"1000000","gasPrice":"0","gasUsed":"51615","cumulativeGasUsed":"1374458","input":"deprecated","confirmations":"6559"}]}

5.이안에 필요한 값들은 from, to, value, 이다. 
deposits테이블에 저장하는 컬럼은 결과값은
from_address, to_address, confirm_usdt, processed_at이며  확인된 최종 입금금액  confirm_usdt만큼 amount_usdp에 저장되고, confirm_usdt만큼 나중에 users테이블의 point 컬럼에 충전되어야해서 중요하다. 트랜젝션해쉬값에 따른 bsc_scan 링크를 생성하여 scan_link 에 저장하고, status = completed 로 하고,
6. users테이블의 point 컬럼에 confirm_usdt만큼 증가시킨다. (이게 매우중요하다.)
7. 최종적으로 처리완료된 결과를 불러와 deposits.php 하단에 표시된다. 이때 처리결과는 completed로 처리완료된다.
8. 관리자페이지에서 확인하는 admin_deposits.php 페이지에서는 디비에 저장된 모든 입금내역을 불러와 표시하고, 미처리된 내역에 대해서는 [입금확인]버튼을 클릭하여 처리할수 있다.
9. 고객도 자신의 deposits.php 페이지에서 입금신청내역을 확인할수 있고, 미처리된 내역이 있을경우, 페이지 로드될때 입금확인 함수를 호출하거나 [입금확인]버튼을 클릭하여 결과값을 업데이트 처리할수 있다.
-------------------

[에러처리]
계속 오류가 나서 다시 처음부터 출발하고자 한다. 당신은 25년차 개발전문가이다. 철처하게 한단게 한단계 처리해 나가자.

deposit.php
1.고객이 입금 신청할 금액(amount_usdt)과 트랜젝션 해쉬값(transaction_id)을 입력후 입금확인버튼을 눌러 제출한다.  여기서는 바로 신청된 입력데이터만 deposits테이블에 저장하고 메세지를 남기고 "처리중" 뜬다. "그러면 정상적으로 접수되었습니다. 네트워크 확인후, 충전됩니다." 라는 메세지를 남기고 일단 deposits테이블에 저장되고 ..그 결과를 불러와 deposits.php 하단에 표시된다. 이때 처리결과는 pending이므로 처리중이 뜬다.
==> 이건 현재 정상으로 됨

2. 디비에 보면 amount_usdt, transaction_id 컬럼에 입력값이 정상으로 찍힘
==>디비에 정상으로 찍힘..

3. 그다음 check_deposit.php에서 실행되어 디비에 있는 transaction_id 값으로 회사주소로 입금되는지 확인하는 작업을 한다


테이블에 저장되는 값은 
user_id, amount_usdt(충전요청금액), transaction_id(트랜잭션해쉬값), status(pending처리상태), created_at(신청일시) 이다

4. 이후 입력된 고객의 "입금신청내역"이 하단에 표시되는데.. 아직 "처리중"상태로 표시된다  ==>여기까지 정상이다

5. 이제 이 회원이 입력한 트렌젝션해쉬값으로 트랜잭션을 호출하여 그 결과값을 deposits테이블에 저장하는 작업이 필요하다.
6. 그런데 현재 이것을 check_deposit.php에서 처리해야 하는데 이게 잘 안되고 며칠째 오류가 난다.
7. admin_deposits.php에서 페이지를 열어 해당 입금신청란ㅇ를 직접 그 신청항목을 찾아서 직접 [입금확인]버튼을 눌러 직접 처리하면 디비에 처리완료된다.
8.이때 admin_deposits.php에서 입금확인 버튼을 눌러서 정상적으로 처리되는 것은 :
회원정보(성명,아이디),	신청금액(amount_usdt)	,
From 주소(from_address)	To 주소(to_address)	트랜잭션 해시(transaction_id),	스캔링크(scan_link)	상태(status)	신청시간(created_at)	
처리시간(processed_at)	
9.정상적으로 처리되지 않아 디비에 저장되지 않는 항목은  확인금액(confirm_usdt),	충전금액(amount_usdp) 이부분이 저장되도록 수정해야한다.
10. 또한 users테이블의 point 컬럼에 충전금액(amount_usdp)만큼 증가시키는것도 안된다. 왜냐면 confirm_usdt 와 amount_usdp가  컬럼에 저장되지 않아서 포인트가 증가되지 않는다. 

그렇다면 from_address, to_address, 가 저장된다는 말은 트랜젝션으로 확인되었다는 말이다.
check_deposit.php에서 처리되는 것인데, 여기 로직에서 확인금액(confirm_usdt), 충전금액(amount_usdp)처리되지 않고 있다는 말이다.

[처리보기] 현재 이것은 check_deposit.php에서 정상적으로는 불러와서 처리되는 것으로 보인다..
함수처리하는 법 .TX 헤쉬값으로 확인하는 작업
나는 직접 입력하여 주소창에 넣어서 아래의 응답값을 받았다. 

(예시) 고객이 입력한 트랜젝션해쉬값 :0x78d98b387f572f1ea40749f46ac3841a4f86f897c60aa6813df67ec5a4a2c747
회사주소 : 0x142A125e6eA59B2eD6d33575985D6D6043A81a07
BSC_API : WX9KE9S86IE93WAC2PXG59NTRPGFJ2XDU6
contractaddress : 0x55d398326f99059fF775485246999027B3197955



// BSC 관련 설정
define('BSC_API_KEY', 'WX9KE9S86IE93WAC2PXG59NTRPGFJ2XDU6');
define('USDT_CONTRACT_ADDRESS', '0x55d398326f99059ff775485246999027b3197955');
define('COMPANY_ADDRESS', '0x142A125e6eA59B2eD6d33575985D6D6043A81a07'); 
트랜젝션해쉬값 예시) : 0x78d98b387f572f1ea40749f46ac3841a4f86f897c60aa6813df67ec5a4a2c747

(예시)
https://api.bscscan.com/api?module=account&action=tokentx&contractaddress=0x55d398326f99059fF775485246999027B3197955&address=0x142A125e6eA59B2eD6d33575985D6D6043A81a07&page=1&offset=100&sort=asc&apikey=WX9KE9S86IE93WAC2PXG59NTRPGFJ2XDU6


11.직접입력했을때 응답값은 다음과 같다.

{"status":"1","message":"OK","result":[{"blockNumber":"43976805","timeStamp":"1731511151","hash":"0x800e63411b1e27f56d18c71d511a9c5906af0e3125c89f49ec0d619e2eba266b","nonce":"645367","blockHash":"0x380e474445c146ecb89f303c4225c215ec83dfb659e5082bbccbf2dab239602a","from":"0x9bb6a22da110c6c9bab745bcaf0ee142ee83af37","contractAddress":"0x55d398326f99059ff775485246999027b3197955","to":"0xfaf0ab8dcbcdc1806a65119c8f59187499e4b910","value":"100000000000000000000","tokenName":"Binance-Peg BSC-USD","tokenSymbol":"BSC-USD","tokenDecimal":"18","transactionIndex":"19","gas":"1000000","gasPrice":"0","gasUsed":"51615","cumulativeGasUsed":"1374458","input":"deprecated","confirmations":"6559"}]}

12.이 응답값 안에 필요한 값들은 from, to, value, 가 다 들어있다.
따라서 deposits테이블에 저장하는 컬럼은 결과값은 from_address, to_address, confirm_usdt, processed_at이며  확인된 최종 입금금액  confirm_usdt만큼 amount_usdp에 저장되고, confirm_usdt만큼 나중에 users테이블의 point 컬럼에 충전되어야해서 중요하다. 
from ==> from_address
to ==> to_address
value ==> confirm_usdt, amount_usdp, users테이블의 point 컬럼에 충전되는 금액  (현재 이부분이 처리되지 않고 있다. 수정한다.)

13. deposits테이블에 저장하는 컬럼은 결과값은 from_address, to_address, confirm_usdt, processed_at이며  확인된 최종 입금금액  confirm_usdt만큼 amount_usdp에 저장되고, confirm_usdt만큼 나중에 users테이블의 point 컬럼에 충전되어야해서 중요하다. 이 모든걸 한꺼번에 디비에 저장해야 한다.
트랜젝션해쉬값에 따른 bsc_scan 링크를 생성하여 scan_link 에 저장하고, status = completed 로 하고,
6. users테이블의 point 컬럼에 confirm_usdt만큼 증가시킨다. (이게 매우중요하다.)
7. 최종적으로 처리완료된 결과를 불러와 deposits.php 하단에 표시된다. 이때 처리결과는 completed로 처리완료된다.
8. 관리자페이지에서 확인하는 admin_deposits.php 페이지에서는 디비에 저장된 모든 입금내역을 불러와 표시하고, 미처리된 내역에 대해서는 [입금확인]버튼을 클릭하여 처리할수 있다.
9. 고객도 자신의 deposits.php 페이지에서 입금신청내역을 확인할수 있고, 미처리된 내역이 있을경우, 페이지 로드될때 입금확인 함수를 호출하거나 [입금확인]버튼을 클릭하여 결과값을 업데이트 처리할수 있다.


이절차 과정대로 제대로 로직이 구현되어 있는지 당신은 전문가로서 deposits.php, check_deposit.php, admin_deposits.php 코드를 최종적으로 정리하여 완성하라.

그런데 deposits.php에서 회원은 입금확인이 처리되어 포인트가 충전되기를 기다리고 있어서,, 이미 트랜젝션으로 보내논거라 회사가 확인만 하면 처리되어야 하는데,, 꼭 관리자에서 일일이 버튼을 눌러줘야 되는 방식이라.. 마냥 회원들은 포인트가 충전되지 않아서 기다리고 있다.
이것을 해결하려고 30초마다 직접 check_deposit.php을 호출해서 디비를 업데이트하게 하려고햇는데 절대 안되고 있다. -->이건 제거해야 할듯.
따라서.. 미처리된 내역이 있을때만 해당 리스트옆에 [입금확인]버튼을 만들어 고객이 직접 클릭하면 자동으로 처리되게 하는 방법을 찾아야 한다. 왜냐면 admin_deposits.php에서도 입금확인 버튼을 눌러서 처리하고 있기때문에 같은 방식으로처리하면 될듯하다.

또한, 더불어 이 방법은 어떤가?
즉, check_deposit.php 파일을 직접 호출하는것보다, check_deposit.php 파일을 include시키고 그안에 check_deposit()함수를 호출하는 방법이 어떨까?
그래서 만약 deposits.php에서 하단 입금신청내역중에 미처리 pending 상태의 내역이 있으면, 즉, 해당 로그인한 id가 deposits테이블에 status가 pending 상태의 내역이 있으면, check_deposit(transaction_id, company_address)등으로 함수를 호출하여 직접 디비에 업데이트시키고 결과를 표시해주면 될듯.. 즉,,함수를 호출하는 방법이 어떨까?

암튼 현재 미처리되고 오류가 나는 부분을 완전하게 검토하여 수정하라,
당신이 현재의 deposits.php, check_deposit.php, admin_deposits.php 코드를 분석하여, 내가 지시하는 이런내용이 얼마나 충실히 반영되어있는지 먼저 당신이 전문가로서 체크하라. 그 다음에 부족한 부분을 하나씩 수정하여 최종적으로 원하는 디비저장과 포인트 업데이트 지급이 이루어져야 한다.
어떤게 안되고 있고 어떻게 수정해야 할지를 당신이 말해라.

CREATE TABLE `deposits` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `amount_usdt` decimal(15,6) NOT NULL COMMENT '송금신청한 USDT 금액',
  `confirm_usdt` decimal(15,6) NOT NULL DEFAULT 0.000000 COMMENT '확인한 USDT금액',
  `amount_usdp` decimal(15,4) NOT NULL COMMENT '충전된 USDP 금액',
  `from_address` varchar(100) NOT NULL COMMENT '송금한 지갑 주소',
  `to_address` varchar(100) NOT NULL COMMENT '회사 지갑 주소',
  `transaction_id` varchar(100) NOT NULL COMMENT '트랜잭션 ID',
  `scan_link` varchar(300) DEFAULT NULL COMMENT '블록체인 스캔 링크',
  `status` enum('pending','completed','failed') DEFAULT 'pending' COMMENT '처리 상태',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp(),
  `processed_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `user_id` (`user_id`),
  CONSTRAINT `deposits_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci


// BSC 관련 설정
define('BSC_API_KEY', 'WX9KE9S86IE93WAC2PXG59NTRPGFJ2XDU6');
define('USDT_CONTRACT_ADDRESS', '0x55d398326f99059ff775485246999027b3197955');
define('COMPANY_ADDRESS', '0x142A125e6eA59B2eD6d33575985D6D6043A81a07'); 


----------------------------
[2안]

계속 오류가 발생해서 다른 방식으로 해보자
나의목표 : 트랜젝션해쉬값을 고객으로부터 입력받아서, 그걸 조회해서 응답값을 받아서 deposits테이블에 저장하는 것이다.
고객은 이미 회사주소로 BSC기반 BEP20 usdt를 송금했고, 트랜젝션해쉬값을 받았다. 
그걸 우리한테 통보해주는 곳이 deposits.php 페이지이다.
우리는 그 트랜젝션해쉬값으로 조회해서 응답값을 받아서 deposits테이블에 저장하고, 그 결과를 고객에게 표시하는 것이다.

1. deposits.php 페이지에서 
고객은 보낸 1)입금신청액과 2)트랜젝션해쉬값을 입력하고 입금확인 신청을 한다.
회사는 그 트랜젝션해쉬값으로 조회해서 응답값을 받아서 deposits테이블에 저장하고, 그 결과를 고객에게 표시하는 것이다.
따라서 트랜젝션해쉬값을 입력하고 신청하기 누르는 순간, 사실상 조회해서 그 응답값을 받아서, 해석해서 각 컬럼값으로 나누어 디비에 저장하면 된다.
저장된 디비값을 불러와 화면에 표시하면 된다.
이게 사실은 한번에 되어야 한다.


2. 단계별로 처리하는 방법
1)고객이 입금신청액과 트랜젝션해쉬값을 입력하고 입금확인신청을 한다.
2)deposits.php 페이지에서 그 트랜젝션해쉬값으로 조회해서 응답값을 받아서 deposits테이블에 저장하고, 포인트를 지급한다.
3)그 결과를 고객에게 표시한다.
4)이렇게 되면 유저는 신청과 동시에 실시간으로 입금확인이 되고, 포인트도 지급되는 것이다.


고객이 폼을 제출하면, check_deposit(transaction_id) 함수를 호출한다.

함수는 아래와 같이 구성된다.

함수는 변수로 transaction_id 만 입력받으면,
나머지 필요한 company_address, USDT_CONTRACT_ADDRESS, BSC_API_KEY 값들은 상수로 선언되있으므로 그대로 사용하면 된다.

고객이 트랜젝션해쉬값을 입력하면, 확인하고자 하는 회사주소와 API키, 컨트랙트주소를 조합하여 조회하면 된다.
(예시) 고객이 입력한 트랜젝션해쉬값 :0x78d98b387f572f1ea40749f46ac3841a4f86f897c60aa6813df67ec5a4a2c747
회사주소 : 0x142A125e6eA59B2eD6d33575985D6D6043A81a07
BSC_API : WX9KE9S86IE93WAC2PXG59NTRPGFJ2XDU6
contractaddress : 0x55d398326f99059fF775485246999027B3197955
(조회생성)
https://api.bscscan.com/api?module=account&action=tokentx&contractaddress=0x55d398326f99059fF775485246999027B3197955&address=0x142A125e6eA59B2eD6d33575985D6D6043A81a07&page=1&offset=100&sort=desc&apikey=WX9KE9S86IE93WAC2PXG59NTRPGFJ2XDU6


[응답값]

{"status":"1","message":"OK","result":[
    {"blockNumber":"44001436",
    "timeStamp":"1731585044",
    "hash":"0x78d98b387f572f1ea40749f46ac3841a4f86f897c60aa6813df67ec5a4a2c747",
    "nonce":"665368","blockHash":"0x0a7338455c9428f05d1e5dd8771e6af3693fa54fb67e0730c7ff1075ef93e8db","from":"0x9bb6a22da110c6c9bab745bcaf0ee142ee83af37",
    "contractAddress":"0x55d398326f99059ff775485246999027b3197955",
    "to":"0x142a125e6ea59b2ed6d33575985d6d6043a81a07",
    "value":"10000000000000000000",
    "tokenName":"Binance-Peg BSC-USD",
    "tokenSymbol":"BSC-USD",
    "tokenDecimal":"18",
    "transactionIndex":"3",
    "gas":"1000000","gasPrice":"0","gasUsed":"34503",
    "cumulativeGasUsed":"419151",
    "input":"deprecated",
    "confirmations":"2002"}
    
    

(응답값중에)
트랜젝션해쉬값 : 0x78d98b387f572f1ea40749f46ac3841a4f86f897c60aa6813df67ec5a4a2c747
첫 번째 트랜잭션 (가장 최근):
hash: 0x78d98b387f572f1ea40749f46ac3841a4f86f897c60aa6813df67ec5a4a2c747
value: "10000000000000000000"
tokenDecimal: "18"
실제 금액 계산: 10000000000000000000 ÷ 10^18 = 10 USDT

(실제필요한것)
여기서 우리가 필요한것은  아래의 항목이고
"hash":"0x78d98b387f572f1ea40749f46ac3841a4f86f897c60aa6813df67ec5a4a2c747", 이미 고객이 입력한 것이지만
"from":"0x9bb6a22da110c6c9bab745bcaf0ee142ee83af37",
"to":"0x142a125e6ea59b2ed6d33575985d6d6043a81a07",
"value":"10000000000000000000",
"tokenSymbol":"BSC-USD",
"tokenDecimal":"18",
"timeStamp":"1731585044",

이중에서 변환이 필요한것은 value 값을 실제 금액으로 변환하는 것이다.
value: "10000000000000000000"
tokenDecimal: "18"
confirm_usdt (실제 금액 계산): 10000000000000000000 ÷ 10^18 = 10 USDT =10
실제 계산이 끝나면 다시 디비에 저장하면 된다.

따라서 deposits테이블에 저장되는 값은 
from_address, to_address, confirm_usdt, amount_usdp, transaction_id, scan_link, status, created_at, processed_at 이다.

함수는 실제입력값 confirm_usdt를 받아서 users테이블에 포인트 point 컬럼에 포인트값을 증가해야 한다. 이게 포인트가 지급된것이다.

이과정을 정리해서 함수로 만들어서.
회원이 deposits.php 페이지에서 입금확인 신청을 하면, 트랜젝션해쉬값을 입력하고 신청버튼을 누르면, 
check_deposit(transaction_id) 함수를 호출하여 처리하는 것이다.
그 결과를 신청페이지에  하단에 신청목록을 불러와 표시하면 된다. status가 completed가 되겠지만, 
어쩻든 확인이 안된경우는 pending인 것은 처리중이고 나중에 관리자에서 처리해주면된다.

이렇게 되면 유저는 신청과 동시에 실시간으로 입금확인이 되고, 포인트도 지급되는 것이다.
신청페이지 deposits.php는 현재 매우 정상적이다.
하지만 단순히 트랜젝션해쉬값을 입력하고 신청하여, deposits테이블에 저장하는것만 현재 하는거고, 실제 트랜젝션을 조회하고 검색하는것은 별도의 뭔가 트리거가 필요하여 복잡하다.
그냥 폼을 제출하면서 함수를 호출하는 것만 하면 된다.

따라서 check_deposit(transaction_id) 함수를 만드는게 당신의 매우 중요한 역할이다. 함수를 만들어 트랜젝션넣어서 테스트해볼수있게 하라.


// BSC 관련 설정
define('BSC_API_KEY', 'WX9KE9S86IE93WAC2PXG59NTRPGFJ2XDU6');
define('USDT_CONTRACT_ADDRESS', '0x55d398326f99059ff775485246999027b3197955');
define('COMPANY_ADDRESS', '0x142A125e6eA59B2eD6d33575985D6D6043A81a07'); 




<h5>리치테크클럽 [부자되기 1호 프로젝트]-와이콘즈 주주되기</h5>
<br><br>
<h6>리치테크클럽 [부자되기 1호 프로젝트]<h6>
<b class="">와이콘즈 주주되기</b> <br><br>
와이콘즈는 대학생통합플랫폼 선두기업입니다. <br>
현재 전국대학교 26개 대학, 253개매장, 30만명의 회원이 함께합니다.<br>
<p></p>
<div class="video-container" style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
    <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/KjN4KgX3cxk" title="[아시아경제TV] 대학생활 플랫폼 선두기업-와이콘즈!  학생식당 예약결제 서비스-야미(Yammi)" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>





<h5>리치테크클럽[부자되기 프로젝트란 무엇인가요?]</h5>
<h6>리치클럽[부자되기 프로젝트 란?] 대하여</h6>
<h6 class="text-primary">리치클럽은 회원들 모두 디지털시대에 신흥부자가 되기위해서 국내외에서 검증된 자산을 발굴하여 회원들에게 
 [부자되기 1호 프로젝트]<h6>
<b class="">와이콘즈 주주되기</b> <br><br>
와이콘즈는 대학생통합플랫폼 선두기업입니다. <br>
현재 전국대학교 26개 대학, 253개매장, 30만명의 회원이 함께합니다.<br>
<p></p>
<div class="video-container" style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;">
    <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/KjN4KgX3cxk" title="[아시아경제TV] 대학생활 플랫폼 선두기업-와이콘즈!  학생식당 예약결제 서비스-야미(Yammi)" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>



<!-- 와이콘즈 야미 예약결제서비스 영상 -->
<div class="notice-container">
  <h5 class="notosans">와이콘즈-야미(Yammi) 예약결제서비스 [영상]</h5>
  <h6 class="notosans">리치클럽 부자되기 프로젝트-와이콘즈 주주되기</h6>
  <p class="notice-text">줄서기 혼잡을 획기적으로 개선한 야미어플</p>

  <h6 class="notosans text-orange">야미2.0 영상</h6>
  <div class="video-wrapper" style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
    <iframe 
      style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
      src="https://www.youtube.com/embed/YPE6mUm8TZk" 
      title="야미 2.0영상 (설치 및 활용편- 연세대학교)" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
      referrerpolicy="strict-origin-when-cross-origin" 
      allowfullscreen>
    </iframe>
  </div>
  
  <p class="mt20 notice-footer">감사합니다.</p>
  <p class="notosans">리치테크 고객관리팀</p>
</div>




<!-- 야미 예약결제서비스 소개 -->
<div class="notice-container">
  <h5 class="notosans">야미(Yammi) 예약결제서비스 소개</h5>
  <h6 class="notosans">고용노동부 중소기업 창업진흥원 우수 창업프로젝트 선정</h6>
  <p class="notice-text">전국대학교 26개 대학, 253개매장, 30만명의 회원이 함께합니다</p>

  <h6 class="notosans text-orange">야미 서비스 소개 영상</h6>
  <div class="video-wrapper" style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
    <iframe 
      style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
      src="https://www.youtube.com/embed/laavWwePsNM?list=PLvsPRum8HWe7ayvDz79D-oq2Q_LE-vUgM" 
      title="아직도 줄 서니? 이제 학교에서도 오더로 미리 주문해! | 교내오더앱, 야미" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
      referrerpolicy="strict-origin-when-cross-origin" 
      allowfullscreen>
    </iframe>
  </div>

  <p class="mt20 notice-footer">감사합니다.</p>
  <p class="notosans">리치테크 고객관리팀</p>
</div>

-----------------
공지사항올리기

<div class="notice-container">
    <h4 class="h3_tl notosans">리치플랜 직급 및 수수료 정책</h4>

    <h5 class="notosans mt50 mb20">1. 추천수당 (총 19%)</h5>
   
    <table class="table table-bordered table-dark table-sm">
        <thead>
            <tr class="bg-gray90 text-white">
                <th class="notosans py-5 bg-gray70 text-center">대수</th>
                <th class="notosans py-5 bg-gray70 text-center">지급률</th>
            </tr>
        </thead>
        <tbody>
            <tr><td class="text-center notosans py-5 bg-gray70">1대</td><td class="text-center py-5">10%</td></tr>
            <tr><td class="text-center notosans py-5 bg-gray70">2대</td><td class="text-center py-5">3%</td></tr>
            <tr><td class="text-center notosans py-5 bg-gray70">3대</td><td class="text-center py-5">2%</td></tr>
            <tr><td class="text-center notosans py-5 bg-gray70">4대</td><td class="text-center py-5">2%</td></tr>
            <tr><td class="text-center notosans py-5 bg-gray70">5대</td><td class="text-center py-5">2%</td></tr>
        </tbody>
    </table>

    <h5 class="notosans mt60 mb20">2. 직급 승급 기준</h5>
    <table class="table table-bordered table-dark table-sm">
        <thead>
            <tr class="bg-gray70 text-white">
                <th class="notosans py-5 bg-gray70 text-center">직급</th>
                <th class="notosans py-5 bg-gray70 text-center">본인매출</th>
                <th class="notosans py-5 bg-gray70 text-center">추천인원</th>
                <th class="notosans py-5 bg-gray70 text-center">소실적 누적실적</th>
            </tr>
        </thead>
        <tbody>
            <tr><td class="notosans text-center py-5 bg-gray70">1스타</td>
            <td class="text-center py-5">1,000 USDT 이상</td><td class="text-center py-5">2명 이상</td><td class="text-center py-5">10,000 USDT 이상</td></tr>
            <tr><td class="notosans text-center py-5 bg-gray70">2스타</td><td class="text-center py-5">1,000 USDT 이상</td><td class="text-center py-5">3명 이상</td><td class="text-center py-5">30,000 USDT 이상</td></tr>
            <tr><td class="notosans text-center bg-gray70">3스타</td><td class="text-center">2,000 USDT 이상</td><td class="text-center">4명 이상</td><td class="text-center">50,000 USDT 이상</td></tr>
            <tr><td class="notosans text-center py-5 bg-gray70">4스타</td><td class="text-center py-5">2,000 USDT 이상</td><td class="text-center py-5">5명 이상</td><td class="text-center py-5">100,000 USDT 이상</td></tr>
            <tr><td class="notosans text-center py-5 bg-gray70">5스타</td><td class="text-center py-5">3,000 USDT 이상</td><td class="text-center py-5">6명 이상</td><td class="text-center py-5">300,000 USDT 이상</td></tr>
            <tr><td class="notosans text-center py-5 bg-gray70">6스타</td><td class="text-center py-5">3,000 USDT 이상</td><td class="text-center py-5">7명 이상</td><td class="text-center py-5">700,000 USDT 이상</td></tr>
            <tr><td class="notosans text-center py-5 bg-gray70">7스타</td><td class="text-center py-5">3,000 USDT 이상</td><td class="text-center py-5">8명 이상</td><td class="text-center py-5">1,000,000 USDT 이상</td></tr>
        </tbody>
    </table>

    <h5 class="notosans mt60 mb20">직급수당 지급요율표 (총 24%)</h5>
    <table class="table table-bordered table-dark table-sm">
        <thead>
            <tr class="bg-gray90 text-white">
                <th class="notosans text-center bg-gray70 py-5">직급</th>
                <th class="notosans text-center bg-gray70 py-5">지급률</th>
                <th class="notosans text-center bg-gray70 py-5">지급방식</th>
            </tr>
        </thead>
        <tbody>
            <tr><td class="notosans text-center bg-gray70">1스타</td><td class="text-center">9%</td><td class="fs-14 notosans">회사당일매출합×9%를 1스타직급자수로 나눔</td></tr>
            <tr><td class="notosans text-center bg-gray70">2스타</td><td class="text-center">4%</td><td class="fs-14 notosans">회사당일매출합×4%를 (2스타+3스타)직급자수로 나눔</td></tr>
            <tr><td class="notosans text-center bg-gray70">3스타</td><td class="text-center">3%</td><td class="fs-14 notosans">회사당일매출합×3%를 (3스타+4스타)직급자수로 나눔</td></tr>
            <tr><td class="notosans text-center bg-gray70">4스타</td><td class="text-center">3%</td><td class="fs-14 notosans">회사당일매출합×2%를 (4스타+5스타)직급자수로 나눔</td></tr>
            <tr><td class="notosans text-center bg-gray70">5스타</td><td class="text-center">2%</td><td class="fs-14 notosans">회사당일매출합×2%를 (5스타+6스타)직급자수로 나눔</td></tr>
            <tr><td class="notosans text-center bg-gray70">6스타</td><td class="text-center">1.5%</td><td class="fs-14 notosans">회사당일매출합×2%를 (6스타+7스타)직급자수로 나눔</td></tr>
            <tr><td class="notosans text-center bg-gray70">7스타</td><td class="text-center">1.5%</td><td class="fs-14 notosans">회사당일매출합×2%를 7스타직급자수로 나눔</td></tr>
        </tbody>
    </table>

    <h5 class="notosans mt50">3. 멘토수당 (2%)</h5>
    <p class="notice-text">여러분의 성공을 지원하는 센터나 강사들에게 지급하는 수당입니다.</p>
</div>



admin_bonus.php 코드 작성
추천수당(bonus_referral 테이블), 직급수당(bonus_rank 테이블), 센터멘토수당(bonus_center 테이블) 각각 개별로 되어있는 수당의 종류와 값을 읽어서 하나의 관리페이지에서 관리하는 관리자 페이지 작성, 디자인 퀄리티,다크모드, 페이징처리, 작은글씨,줄간간격 좁게, 테이블 표시 예시 참고

1. 대쉬보드 박스
수당총액  추천수당, 직급수당, 센터멘토수당 총액을 표시

2. 검색컨트롤 부분
[수당종류] 추천수당, 직급수당, 센터멘토수당 셀렉트박스로 구성,[회원명] 입력창, [기간설정]입력창,[검색]버튼, [엑셀저장]버튼


3. 수당종류별 탭을 선택하면 해당 수당별 테이블이 표시된다.
[전체], [추천수당], [직급수당], [센터멘토수당] 각각 탭으로 구성

각 수당별로 테이블 전체표시
항목이 많으니 표는 내용이 길면 가로 스크롤이 되도록 하라. 줄간간격은 최소로 하고 촘촘히 해서 여러줄이 표시되도록 한다.
각각 페이징 처리를 한다.


CREATE TABLE `bonus_referral` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `order_id` int(11) NOT NULL COMMENT '수당 발생 주문 ID',
  `source_user_id` int(11) NOT NULL,
  `source_amount` decimal(15,2) NOT NULL COMMENT '매출 금액',
  `level` int(10) NOT NULL COMMENT '추천 단계 (1~5)',
  `commission_rate` decimal(5,2) NOT NULL COMMENT '수수료 비율 (%)',
  `amount` decimal(15,2) NOT NULL COMMENT '수당 금액',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp() COMMENT '수당 발생 일시',
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_order_id` (`order_id`),
  KEY `idx_source_user_id` (`source_user_id`),
  CONSTRAINT `fk_bonus_referral_order` FOREIGN KEY (`order_id`) REFERENCES `orders` (`id`),
  CONSTRAINT `fk_bonus_referral_source_user` FOREIGN KEY (`source_user_id`) REFERENCES `users` (`id`),
  CONSTRAINT `fk_bonus_referral_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='추천수당 내역'



CREATE TABLE `bonus_rank` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `rank` varchar(10) NOT NULL COMMENT '수령자 직급',
  `bonus_type` varchar(20) NOT NULL COMMENT '수당 유형',
  `total_company_sales` decimal(15,2) NOT NULL COMMENT '회사 총 매출액',
  `commission_rate` decimal(5,2) NOT NULL COMMENT '수수료 비율 (%)',
  `amount` decimal(15,2) NOT NULL COMMENT '수당 금액',
  `applicable_ranks` varchar(50) NOT NULL COMMENT '수당 적용 대상 직급',
  `total_rank_members` int(11) NOT NULL COMMENT '수당 적용 대상 인원수',
  `calculation_date` date NOT NULL COMMENT '수당 계산 날짜',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp() COMMENT '수당 발생 일시',
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_calculation_date` (`calculation_date`),
  CONSTRAINT `fk_bonus_rank_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='직급수당 내역'



CREATE TABLE `bonus_center` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `organization_id` int(11) NOT NULL COMMENT '센터 ID',
  `user_id` int(11) NOT NULL,
  `total_sales` decimal(15,2) NOT NULL COMMENT '센터 총 매출액',
  `commission_rate` decimal(5,2) NOT NULL DEFAULT 2.00 COMMENT '수수료 비율 (%)',
  `amount` decimal(15,2) NOT NULL COMMENT '센터장 수수료 금액',
  `sales_date` date NOT NULL COMMENT '매출 집계 날짜',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp() COMMENT '수당 발생 일시',
  PRIMARY KEY (`id`),
  KEY `idx_organization_id` (`organization_id`),
  KEY `idx_center_user_id` (`user_id`),
  KEY `idx_sales_date` (`sales_date`),
  CONSTRAINT `fk_bonus_center_organization` FOREIGN KEY (`organization_id`) REFERENCES `organizations` (`id`),
  CONSTRAINT `fk_bonus_center_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='센터 수수료 내역'









-----

[응답값]

{"status":"1","message":"OK","result":[
    {"blockNumber":"44001436",
    "timeStamp":"1731585044",
    "hash":"0x78d98b387f572f1ea40749f46ac3841a4f86f897c60aa6813df67ec5a4a2c747",
    "nonce":"665368","blockHash":"0x0a7338455c9428f05d1e5dd8771e6af3693fa54fb67e0730c7ff1075ef93e8db","from":"0x9bb6a22da110c6c9bab745bcaf0ee142ee83af37",
    "contractAddress":"0x55d398326f99059ff775485246999027b3197955",
    "to":"0x142a125e6ea59b2ed6d33575985d6d6043a81a07",
    "value":"10000000000000000000",
    "tokenName":"Binance-Peg BSC-USD",
    "tokenSymbol":"BSC-USD",
    "tokenDecimal":"18",
    "transactionIndex":"3",
    "gas":"1000000","gasPrice":"0","gasUsed":"34503",
    "cumulativeGasUsed":"419151",
    "input":"deprecated",
    "confirmations":"2002"}
    
    
    
    
    





1.현재 당신이 제시한 안대로 코드를 작성하고 실행했을때.. 3개의 파일  전체코드 먼저 당신이 제시한대로 올바로 코드가 모아졌는지 확인하라.
2.deposits.php는  정상적으로 디비에 기록되고,,하단에 대기중 pending이 나오고 버튼이 생기고한다. 하지만 입금확인을 위해 버튼을 클릭하면 입금확인 누르면 "Unexpected token '<', "<!DOCTYPE "... is not valid JSON" 공포의 json오류가 나온다..
=>이거 매번 나오는 건데 수정이 어려운 공포다.

3. check_deposits.php는 여전히  트랜젝션을 호출해서 받은 응답값에서 다른 From,To 주소등은 다 읽어와서 디비에 저장하는데.
confirm_usdt, amount_usdp 컬럼에 제대로 저장되지 않고 있다. 트랜젝션에서 실제 값을 못불러오는지 답하라, 불러온다면 적절한 형태로 변환을 못해서 0으로 기록되는지 그것도 확인하라. 불러오는데 값을 숫자로 변환을 못하여 값 value를 제대로 못불러오고 있는듯하다.  이게 안되니 포인트도 누적이 안된다.



---


10. 당신이 처리해야 할 가장 큰 일은 트랜젝션해쉬값으로 check_deposit()함수를 작성하여 회사주소로 입금되는지 deposits테이블에 저장되는 것이 무엇보다도 중요하다, 그 값을 올바로 디비에 저장해야 모든 일이 이루어지기 때문이다.

deposits.php코드, check_deposit()함수, admin_deposits.php 코드를 최종적으로 정리하여 완성하라.
그동안 여러버전의 deposits.php 코드를 수정하면서 엉망진창이 되어버린 코드를 최종적으로 정리하여 완성하라.

---------

[출금신청]
withdrawals.php 페이지에서 출금신청을 한다. 
기존에는 트론방식 USDT 출금방식인데, 수수료가 너무 비싸서 이것을 BSC방식의 usdt출금주소로 신청서를 변환해 주어야 한다.

회원들은 출금신청 폼에서 1)출금신청 금액(request_amount_usdp)과 2)전송받을 BSC USDT주소(to_address)를 입력하고 출금신청버튼을 눌러 제출한다.
출금신청시 금액과 수수료 3%를 제외한 금액이 실제로 출금되는 금액이 된다. 
두가지를 정확하게 입력하여 출금신청을 하여야 한다.

1. withdrawals.php는 바로 신청값만 withdrawals테이블에 저장하고 메세지를 남기고 하단에 처리중이 뜬다.
"그러면 정상적으로 출금신청이 접수되었습니다. 확인후,익일 지정시간에 출금됩니다." 라는 메세지를 남기고 일단 withdrawals테이블에 저장되고 ..그 결과를 불러와 withdrawals.php 하단에 표시된다. 이때 처리결과는 pending이므로 처리중이 뜬다.

2. 출금신청시 테이블에 저장되는 값은 
user_id, request_amount_usdp, fee_percentage, fee_amount, actual_amount_usdt, to_address, status, created_at 이다.
출금신청이 되면, 고객의 users테이블에 point가 request_amount_usdp만큼 차감된다.


3. 신청과 동시에 고객의 "출금신청내역"이 하단에 표시되는데.. 아직 "처리중"상태이다. 디자인은 기존에 deposits.php와 동일하게 참조하라.
출금은 관리자페이지에서 각 신청건을 확인후 출금하기 버튼을 클릭하면 출금요청한 주소로 입금처리되고, 처리결과는 status="completed" 완료로 하고, 처리일시는 processed_at으로 기록된다. 

4. 출금신청내역에 표시될 항목은
신청자 : user_id, 
출금신청금액 : request_amount_usdp, 
수수료율: fee_percentage, 수수료 : fee_amount, 실제출금금액 : actual_amount_usdt, 출금주소 : to_address, 
처리상태 : status, 신청일 : created_at, 처리일 : processed_at 이다.

처리상태는 관리자가 입력전에는 pending, 관리자가 입력하면 completed, 오류시 failed로 한다.

admin_withdrawals.php 페이지에서 출금신청내역을 확인하고, 출금하기 버튼을 클릭하면 출금요청한 주소로 입금처리되고, 처리결과는 status="completed" 완료로 하고, 처리일시는 processed_at으로 기록된다.
다음은 admin_withdrawals.php를 관리자가 최대한 잘 출금내역을 관리하고 처리할수 있도록 관리자 페이지를 구성하라. 
당분간은 일일이 출금신청한 건들의 주소와 금액을 복사해서 수동으로 하나씩 전송하려고 한다. 
따라서 to_address와 actual_amount_usdt 컬럼 옆에 복사하기 버튼이 있어야 한다.
또한 출금 트랜젝션값을 입력할수 있도록 transaction_id 컬럼은 입력이 가능하여야하고 옆에 [수정버튼]이 있어 입력이 가능해야 하며, 스캔링크 scan_link 컬럼은 트랜젝션컬럼이 입력되면 자동으로 생성되어 입력창에 떠서 저장되어야 한다.
출금처리,미처리 결과가 표시되어야 하고, 미처리 부분만 관리자가 확인하여 출금한후 [출금처리]버튼을 누르면 최종 결과처리가 완료된다.

일단 모든 정보가 테이블에 표시되도록 항목을  디비에 있는 모든 항목이 표시되어 정보를 볼수 있도록 하라. 표는 내용이 길면 가로 스크롤이 되도록 하라.
미처리가 있을경우만 주소와 금액을 복사해서 처리하는 것이 주요기능이고, 나머지는 그냥 디비내용 불러오는것이다.
처리완료는 주소와 금액 복사버튼이 필요없다.


withdrawals.php코드, admin_withdrawals.php 코드를 최종적으로 정리하여 완성하라.
그동안 여러버전의 withdrawals.php 코드를 수정하면서 엉망진창이 되어버린 코드를 최종적으로 정리하여 완성하라.




CREATE TABLE `withdrawals` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `request_amount_usdp` decimal(15,4) NOT NULL COMMENT '출금 신청한 USDP 금액',
  `fee_percentage` decimal(5,2) DEFAULT 3.00 COMMENT '출금 수수료 (%)',
  `fee_amount` decimal(15,4) NOT NULL COMMENT '출금 수수료 금액',
  `actual_amount_usdt` decimal(15,6) NOT NULL COMMENT '실제 출금되는 USDT 금액',
  `to_address` varchar(100) NOT NULL COMMENT '사용자의 트론 주소',
  `transaction_id` varchar(100) DEFAULT NULL COMMENT '출금 트랜잭션 ID',
  `scan_link` varchar(500) DEFAULT NULL COMMENT '트론스캔링크',
  `status` enum('pending','completed','failed') DEFAULT 'pending' COMMENT '처리 상태',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp(),
  `processed_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `user_id` (`user_id`),
  CONSTRAINT `withdrawals_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci








4. 회사는 마스터계좌에서 회원들의 트론계좌로 실제 출금되는 금액(actual_amount_usdt)을 전송한다.
여기에서 당신이 할일이  회원들의 트론계좌(tron_address)로 실제금액(actual_amount_usdt)을 전송해주는 것과 출금이 되었는지 확인하는 코드를 작성하는것이다. 전송해주고 전송트랜젝션(transaction_id)과 트론스캔링크(tronscan_link)를 조회해서 withdrawals테이블에 저장하고, 상태값은 status="completed" 완료일은 (processed_at)로 하여 해당출금건은 종료한다. 
5. 회사는 출금이 완료되면 출금테이블(withdrawals)에 정보를 저장하고, 회원들의 포인트(points)에서 출금요청액(request_amount_usdp)만큼을 차감한다.

매일 10시부터 5시까지 출금요청을 받는다. 
전날 신청분은 전송은 수동또는 자동으로 매일 10시에 일괄 순차적으로 송금한다.

신청된 withdrawals테이블의 정보는 admin_withdrawals.php에서 확인하면서, 회원을 선택하여 부분 또는 전체를 선택하여 출금하기 버튼을 통해서 수동으로도 출금할수 있다. 수동이 아니면 매일 10시에 일괄 순차적으로 송금한다.
이 부분의 코드를 당신이 작성해야 한다.


--------------------------------
보너스 발생일 표시 수정
1. 추천수당은 매출오더가 발생한 날을 기준으로한다. 현재는 bonus_referral 테이블에 저장된 날짜를 기준으로 표시되고 있는데, 오더가 발생한 날을 기준으로 표시되도록 수정하라.그럴려면 오더테이블에 저장된 날짜를 기준으로 하면 된다.
추천수당은 각 오더 1건당 발생하므로, 추천수당 계산하여 bonus_referral 테이블에 저장할떼 
2. 직급수당은 오더가 발생한 날을 기준으로한다.
3. 센터수당은 매출이 발생한 날을 기준으로한다.



추천보너스(bonus_referral)테이블의  수당발생일을 찾기 위해 먼저 매출이 나온날 즉 order_date 컬럼값을 찾아야 한다. 만약 order_date값이 비어있으면. 추천보너스 테이블(bonus_referral)에 있는 order_id컬럼값을 활용해 orders테이블에서 id를 조회하여 created_at의 값을 불러와서 bonus_referral테이블의 order_date값에 먼저저장해야 한다.

그래서 추천수당 발생일은 order_date 값으로 한다. 현재는 추천보너스 테이블의 생성일(created_at)로 되어있는데 이것을 order_date로 수정하라.
실제 매출발생일있다. 따라서 orders 테이블에서 의 값을 불러오기전에 오더테이블에 저장된 날짜(created_at)를 기준으로 표시되도록 수정하라.

추천수당 계산후, 추천수당 테이블인 bonus_referral테이블에 저장할때  order_date컬럼에 값을 orders테이블의 주문정보에서 created_at 값을 불러와 저장하라
당신은 이 지시사항을 이해 하였는가? 추천보너스 계산함수는 모든 기능이 매우 정상이다. 
따라서 이 컬럼값만 저장하면되니 다른 기능은 절대 건드리지 마라.


 도 함께 저장하라.

장된 날짜는 수당발생일(order_date)이다. 이것을 수당계산일(created_at)로 수정하라.


CREATE TABLE `orders` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `product_id` int(11) NOT NULL COMMENT '상품코드',
  `price_unit` decimal(10,0) DEFAULT NULL COMMENT '단위가격',
  `quantity` int(11) NOT NULL COMMENT '수량',
  `total_amount` decimal(10,2) NOT NULL COMMENT '결제금액',
  `point_used` decimal(10,2) DEFAULT NULL COMMENT '결제포인트',
  `stock` int(11) DEFAULT NULL COMMENT '지급주식수',
  `token` decimal(15,2) DEFAULT 0.00 COMMENT '지급토큰수량',
  `payment_method` varchar(100) DEFAULT 'usdp' COMMENT '결제방식',
  `cash_point_used` decimal(10,2) DEFAULT 0.00 COMMENT '현금포인트결제',
  `mileage_point_used` decimal(10,2) DEFAULT 0.00 COMMENT '마일리지결제',
  `payment_date` datetime DEFAULT NULL COMMENT '결제일',
  `status` enum('pending','paid','completed','cancelled') DEFAULT 'pending' COMMENT '결제상태',
  `paid_referral` enum('pending','completed') DEFAULT 'pending' COMMENT '추천수당정산여부',
  `paid_status` enum('pending','completed') DEFAULT 'pending' COMMENT '직급수당정산상태',
  `paid_center` enum('pending','completed') DEFAULT 'pending' COMMENT '센터피정산여부',
  `currency` char(3) DEFAULT 'USD' COMMENT '화폐단위',
  `ip_address` varchar(45) DEFAULT NULL COMMENT '주문IP',
  `updated_at` timestamp NULL DEFAULT current_timestamp() ON UPDATE current_timestamp() COMMENT '수정일',
  `created_at` timestamp NULL DEFAULT current_timestamp() COMMENT '생성일',
  PRIMARY KEY (`id`),
  KEY `user_id` (`user_id`),
  KEY `product_id` (`product_id`),
  CONSTRAINT `fk_orders_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci



CREATE TABLE `bonus_referral` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `order_id` int(11) NOT NULL COMMENT '수당 발생 주문 ID',
  `source_user_id` int(11) NOT NULL,
  `source_amount` decimal(15,2) NOT NULL COMMENT '매출 금액',
  `level` int(10) NOT NULL COMMENT '추천 단계 (1~5)',
  `commission_rate` decimal(5,2) NOT NULL COMMENT '수수료 비율 (%)',
  `amount` decimal(15,2) NOT NULL COMMENT '수당 금액',
  `order_date` timestamp NOT NULL DEFAULT current_timestamp() ON UPDATE current_timestamp() COMMENT '수당발생일',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp() COMMENT '수당계산일',
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_order_id` (`order_id`),
  KEY `idx_source_user_id` (`source_user_id`),
  CONSTRAINT `fk_bonus_referral_order` FOREIGN KEY (`order_id`) REFERENCES `orders` (`id`),
  CONSTRAINT `fk_bonus_referral_source_user` FOREIGN KEY (`source_user_id`) REFERENCES `users` (`id`),
  CONSTRAINT `fk_bonus_referral_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='추천수당 내역'





CREATE TABLE `bonus_rank` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `rank` varchar(10) NOT NULL COMMENT '수령자 직급',
  `bonus_type` varchar(20) NOT NULL COMMENT '수당 유형',
  `total_company_sales` decimal(15,2) NOT NULL COMMENT '회사 총 매출액',
  `commission_rate` decimal(5,2) NOT NULL COMMENT '수수료 비율 (%)',
  `amount` decimal(15,2) NOT NULL COMMENT '수당 금액',
  `applicable_ranks` varchar(50) NOT NULL COMMENT '수당 적용 대상 직급',
  `total_rank_members` int(11) NOT NULL COMMENT '수당 적용 대상 인원수',
  `calculation_date` date NOT NULL COMMENT '수당 계산 날짜',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp() COMMENT '수당 발생 일시',
  PRIMARY KEY (`id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_calculation_date` (`calculation_date`),
  CONSTRAINT `fk_bonus_rank_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='직급수당 내역'




CREATE TABLE `bonus_center` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `organization_id` int(11) NOT NULL COMMENT '센터 ID',
  `user_id` int(11) NOT NULL,
  `total_sales` decimal(15,2) NOT NULL COMMENT '센터 총 매출액',
  `commission_rate` decimal(5,2) NOT NULL DEFAULT 2.00 COMMENT '수수료 비율 (%)',
  `amount` decimal(15,2) NOT NULL COMMENT '센터장 수수료 금액',
  `sales_date` date NOT NULL COMMENT '매출 집계 날짜',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp() COMMENT '수당 발생 일시',
  PRIMARY KEY (`id`),
  KEY `idx_organization_id` (`organization_id`),
  KEY `idx_center_user_id` (`user_id`),
  KEY `idx_sales_date` (`sales_date`),
  CONSTRAINT `fk_bonus_center_organization` FOREIGN KEY (`organization_id`) REFERENCES `organizations` (`id`),
  CONSTRAINT `fk_bonus_center_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='센터 수수료 내역'
